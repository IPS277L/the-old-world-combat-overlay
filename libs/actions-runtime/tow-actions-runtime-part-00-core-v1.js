// Auto-generated by macros/tools/build-actions-runtime-libs.mjs
// Registers actions runtime source part: 00-core
(() => {
  const bundle = game["towActionsRuntimeBundleV1"] ?? (game["towActionsRuntimeBundleV1"] = {
    version: "1.0.0",
    parts: new Map(),
    order: ["00-core","10-attack-flow","20-defence-flow","30-api"]
  });
  bundle.version = "1.0.0";
  if (!(bundle.parts instanceof Map)) bundle.parts = new Map();
  bundle.parts.set("00-core", "// Shared TOW action library (Foundry V13)\n// Provides reusable attack/defence flows for other macros and overlay controls.\n\nconst TOW_ACTIONS_KEY = \"towActions\";\nconst TOW_ACTIONS_VERSION = \"1.0.0\";\nconst SHIFT_KEY = foundry.helpers.interaction.KeyboardManager.MODIFIER_KEYS.SHIFT;\nconst DEFAULT_DEFENCE_SKILL = \"defence\";\nconst SELF_ROLL_CONTEXT = { skipTargets: true, targets: [] };\nconst ATTACK_CALL_DEDUPE_MS = 700;\nconst DAMAGE_RENDER_DEDUPE_MS = 120000;\n\nfunction isShiftHeld() {\n  return game.keyboard.isModifierActive(SHIFT_KEY);\n}\n\nfunction shouldExecuteAttack(actor, { manual = false } = {}) {\n  if (!actor) return false;\n\n  const api = game[TOW_ACTIONS_KEY];\n  if (!api) return true;\n  if (!api._attackCallDeduper) api._attackCallDeduper = new Map();\n\n  const key = `${game.user.id}:${actor.id}:${manual ? \"manual\" : \"auto\"}`;\n  const now = Date.now();\n  const last = Number(api._attackCallDeduper.get(key) ?? 0);\n  if (now - last < ATTACK_CALL_DEDUPE_MS) return false;\n\n  api._attackCallDeduper.set(key, now);\n\n  if (api._attackCallDeduper.size > 200) {\n    for (const [entryKey, ts] of api._attackCallDeduper.entries()) {\n      if (now - Number(ts) > ATTACK_CALL_DEDUPE_MS * 3) api._attackCallDeduper.delete(entryKey);\n    }\n  }\n\n  return true;\n}\n\nfunction toElement(appElement) {\n  if (!appElement) return null;\n  if (appElement instanceof HTMLElement) return appElement;\n  if (appElement[0] instanceof HTMLElement) return appElement[0];\n  return null;\n}\n\nfunction scheduleSoon(callback) {\n  if (typeof window?.requestAnimationFrame === \"function\") {\n    window.requestAnimationFrame(() => {\n      void callback();\n    });\n    return;\n  }\n  Promise.resolve().then(() => {\n    void callback();\n  });\n}\n\nfunction escapeHtml(value) {\n  return foundry.utils.escapeHTML(String(value ?? \"\"));\n}\n\nfunction isRangedAttack(attackItem) {\n  return (attackItem.system.attack.range?.max ?? 0) > 0;\n}\n\nfunction isWeaponAttack(item) {\n  if (item.type !== \"ability\" || !item.system?.attack) return false;\n  if (item.system?.isAttack === true) return true;\n  return typeof item.system.attack.skill === \"string\" && item.system.attack.skill.length > 0;\n}\n\nfunction getSortedWeaponAttacks(actor) {\n  return actor.items\n    .filter(isWeaponAttack)\n    .sort((a, b) => {\n      const aRanged = isRangedAttack(a);\n      const bRanged = isRangedAttack(b);\n      if (aRanged !== bRanged) return aRanged ? 1 : -1;\n      return a.name.localeCompare(b.name);\n    });\n}\n\nfunction getAttackMeta(attack) {\n  const skill = attack.system?.attack?.skill;\n  const skillLabel = game.oldworld?.config?.skills?.[skill] ?? skill ?? \"Attack\";\n  const attackType = attack.system?.isRanged || isRangedAttack(attack) ? \"Ranged\" : \"Melee\";\n  const rangeConfig = game.oldworld?.config?.range ?? {};\n  const meleeRangeKey = attack.system?.attack?.range?.melee;\n  const minRangeKey = attack.system?.attack?.range?.min;\n  const maxRangeKey = attack.system?.attack?.range?.max;\n  const rangeLabel = attackType === \"Ranged\"\n    ? `${rangeConfig[minRangeKey] ?? minRangeKey ?? 0}-${rangeConfig[maxRangeKey] ?? maxRangeKey ?? 0}`\n    : `${rangeConfig[meleeRangeKey] ?? meleeRangeKey ?? 0}`;\n  const damage = Number(attack.system?.damage?.value ?? 0);\n  return `${attackType} | ${rangeLabel} | ${skillLabel} | DMG ${damage}`;\n}\n\nfunction renderSelectorRowButton({\n  rowClass,\n  dataAttrs = \"\",\n  label,\n  valueLabel = \"\",\n  subLabel = \"\",\n  highlighted = false,\n  compact = false\n} = {}) {\n  const safeLabel = escapeHtml(label);\n  const safeValue = escapeHtml(valueLabel);\n  const safeSubLabel = escapeHtml(subLabel);\n\n  const labelColor = highlighted ? \"#2c2412\" : \"#111111\";\n  const subLabelColor = highlighted ? \"#4d4121\" : \"#5f5b4b\";\n  const buttonBackground = highlighted ? \"#e8ddbe\" : \"#f2f1e8\";\n  const buttonBorder = highlighted ? \"#8f7c43\" : \"#bdb9ab\";\n  const buttonShadow = highlighted ? \"inset 0 0 0 1px rgba(255,255,255,0.35)\" : \"none\";\n  const accentColor = highlighted ? \"#6a5623\" : \"transparent\";\n  const accent = `<span style=\"width:4px; align-self:stretch; border-radius:2px; background:${accentColor}; flex:0 0 auto;\"></span>`;\n\n  const hasSubLabel = safeSubLabel.length > 0;\n  const subtitleMarkup = hasSubLabel\n    ? `<span style=\"font-size:11px; line-height:1.2; color:${subLabelColor}; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\">${safeSubLabel}</span>`\n    : \"\";\n\n  const valueMarkup = safeValue\n    ? `<span style=\"font-size:12px; opacity:0.85; flex:0 0 auto; color:#2f2a1f;\">${safeValue}</span>`\n    : \"\";\n\n  const compactHeight = compact ? \"34px\" : \"\";\n  const minHeight = compact ? \"34px\" : \"52px\";\n  const padding = compact ? \"5px 6px\" : \"6px\";\n\n  return `<button type=\"button\"\n    class=\"${rowClass}\"\n    ${dataAttrs}\n    style=\"width:100%; box-sizing:border-box; text-align:left; padding:${padding}; min-height:${minHeight}; ${compactHeight ? `height:${compactHeight};` : \"\"} display:flex; align-items:center; justify-content:space-between; gap:8px; background:${buttonBackground}; border:1px solid ${buttonBorder}; box-shadow:${buttonShadow}; border-radius:3px;\">\n    <span style=\"display:flex; align-items:center; gap:7px; min-width:0; flex:1;\">\n      ${accent}\n      <span style=\"display:flex; flex-direction:column; justify-content:center; min-width:0; gap:1px;\">\n        <span style=\"font-weight:400; color:${labelColor}; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;\">${safeLabel}</span>\n        ${subtitleMarkup}\n      </span>\n    </span>\n    ${valueMarkup}\n  </button>`;\n}\n\nasync function waitForChatMessage(messageId, timeoutMs = 3000) {\n  if (!messageId) return null;\n  const existing = game.messages.get(messageId);\n  if (existing) return existing;\n\n  return new Promise((resolve) => {\n    let settled = false;\n    let timeoutId = null;\n    let hookId = null;\n\n    const finish = () => {\n      if (settled) return;\n      settled = true;\n      if (hookId) Hooks.off(\"createChatMessage\", hookId);\n      if (timeoutId) clearTimeout(timeoutId);\n      resolve(game.messages.get(messageId) ?? null);\n    };\n\n    hookId = Hooks.on(\"createChatMessage\", (message) => {\n      if (message?.id !== messageId) return;\n      finish();\n    });\n\n    timeoutId = setTimeout(finish, timeoutMs);\n  });\n}\n\nfunction getDamageRenderState() {\n  const api = game[TOW_ACTIONS_KEY];\n  if (!api) return null;\n  if (!api._damageRenderDeduper) api._damageRenderDeduper = new Map();\n  return api._damageRenderDeduper;\n}\n\nfunction markDamageRender(dedupe, key) {\n  if (!dedupe || !key) return false;\n  const now = Date.now();\n  const last = Number(dedupe.get(key) ?? 0);\n  if (now - last < DAMAGE_RENDER_DEDUPE_MS) return false;\n  dedupe.set(key, now);\n\n  if (dedupe.size > 250) {\n    for (const [entryKey, ts] of dedupe.entries()) {\n      if (now - Number(ts) > DAMAGE_RENDER_DEDUPE_MS * 2) dedupe.delete(entryKey);\n    }\n  }\n  return true;\n}\n\nasync function postSeparateDamageMessage(message, damage) {\n  if (!message) return;\n  const targetCount = Number(message.system?.test?.context?.targetSpeakers?.length ?? 0);\n  if (targetCount > 0) return; // Do not interfere with opposed creation/update flows.\n\n  const dedupe = getDamageRenderState();\n  const dedupeKey = `separate:${message.id}`;\n  if (!markDamageRender(dedupe, dedupeKey)) return;\n\n  const content = `<div style=\"\n      border-top: 1px solid rgba(130,110,80,0.45);\n      border-bottom: 1px solid rgba(130,110,80,0.45);\n      margin: 4px 0;\n      padding: 6px 8px;\n      text-align: center;\n      font-size: var(--font-size-16);\n      letter-spacing: 0.04em;\n      opacity: 0.9;\">\n      <strong>Damage:</strong> ${Number(damage ?? 0)}\n    </div>`;\n\n  await ChatMessage.create({\n    content,\n    speaker: message.speaker ?? {}\n  });\n}\n\nasync function renderDamageDisplay(message, { damage }) {\n  if (!message) return;\n  await postSeparateDamageMessage(message, damage);\n}\n");
})();
