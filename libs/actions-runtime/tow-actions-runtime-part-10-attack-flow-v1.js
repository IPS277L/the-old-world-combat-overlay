// Auto-generated by macros/tools/build-actions-runtime-libs.mjs
// Registers actions runtime source part: 10-attack-flow
(() => {
  const bundle = game["towActionsRuntimeBundleV1"] ?? (game["towActionsRuntimeBundleV1"] = {
    version: "1.0.0",
    parts: new Map(),
    order: ["00-core","10-attack-flow","20-defence-flow","30-api"]
  });
  bundle.version = "1.0.0";
  if (!(bundle.parts instanceof Map)) bundle.parts = new Map();
  bundle.parts.set("10-attack-flow", "function armDamageAppend(actor, ability) {\n  let timeoutId = null;\n\n  const cleanup = (hookId) => {\n    Hooks.off(\"createChatMessage\", hookId);\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  const hookId = Hooks.on(\"createChatMessage\", async (message) => {\n    const test = message?.system?.test;\n    const sameActor = test?.context?.actor === actor.uuid;\n    const sameItem = test?.context?.itemUuid === ability.uuid;\n    if (!sameActor || !sameItem) return;\n\n    cleanup(hookId);\n    const flatDamage = test?.testData?.damage ?? ability.system.damage?.value ?? 0;\n    await renderDamageDisplay(message, { damage: flatDamage });\n  });\n\n  timeoutId = setTimeout(() => cleanup(hookId), 30000);\n}\n\nfunction armAutoSubmitDialog({ hookName, matches, submitErrorMessage }) {\n  Hooks.once(hookName, (app) => {\n    if (!matches(app)) return;\n\n    const element = toElement(app?.element);\n    if (element) {\n      element.style.visibility = \"hidden\";\n      element.style.pointerEvents = \"none\";\n    }\n\n    scheduleSoon(async () => {\n      if (typeof app?.submit !== \"function\") {\n        console.error(`[tow-actions-lib-v1] ${submitErrorMessage}`);\n        if (element) {\n          element.style.visibility = \"\";\n          element.style.pointerEvents = \"\";\n        }\n        return;\n      }\n      await app.submit();\n    });\n  });\n}\n\nfunction armAutoSubmitAbilityDialog(actor, ability) {\n  armAutoSubmitDialog({\n    hookName: \"renderAbilityAttackDialog\",\n    matches: (app) => app?.actor?.id === actor.id && app?.ability?.id === ability.id,\n    submitErrorMessage: \"AbilityAttackDialog.submit() is unavailable.\"\n  });\n}\n\nasync function setupAbilityTestWithDamage(actor, ability, { autoRoll = false } = {}) {\n  // Always arm chat listener first because some roll paths do not expose messageId reliably.\n  armDamageAppend(actor, ability);\n\n  let testRef;\n\n  if (autoRoll) {\n    armAutoSubmitAbilityDialog(actor, ability);\n    testRef = await actor.setupAbilityTest(ability);\n  } else {\n    testRef = await actor.setupAbilityTest(ability);\n  }\n\n  if (!testRef) return null;\n\n  const flatDamage = testRef.testData?.damage ?? ability.system.damage?.value ?? 0;\n  const message = await waitForChatMessage(testRef.context?.messageId);\n  await renderDamageDisplay(message, { damage: flatDamage });\n  return testRef;\n}\n\nfunction renderAttackSelector(actor, attacks, { onFastAuto } = {}) {\n  const buttonMarkup = attacks\n    .map((attack, index) => {\n      const itemId = escapeHtml(attack.id);\n      return renderSelectorRowButton({\n        rowClass: \"attack-btn\",\n        dataAttrs: `data-id=\"${itemId}\"`,\n        label: attack.name,\n        subLabel: getAttackMeta(attack),\n        valueLabel: \"\",\n        highlighted: index === 0,\n        compact: false\n      });\n    })\n    .join(\"\");\n\n  const content = `<div style=\"display:flex; flex-direction:column; min-width:0; border:1px solid #b9b6aa; border-radius:4px; overflow:hidden;\">\n    <div style=\"padding:4px 6px; font-size:12px; font-weight:700; background:#d9d5c7;\">Attacks</div>\n    <div style=\"display:flex; flex-direction:column; gap:4px; padding:6px; overflow-y:auto; overflow-x:hidden; max-height:430px; scrollbar-gutter:stable;\">\n      ${buttonMarkup || '<div style=\"font-size:12px; opacity:0.7;\">No attacks</div>'}\n    </div>\n  </div>`;\n  const selectorDialog = new Dialog({\n    title: `${actor.name} - Weapon Attacks`,\n    content,\n    width: 560,\n    height: 560,\n    buttons: { close: { label: \"Close\" } },\n    render: (html) => {\n      html.find(\".attack-btn\").on(\"click\", async (event) => {\n        const chosen = actor.items.get(event.currentTarget.dataset.id);\n        if (!chosen) return;\n        const fastRoll = event.shiftKey === true;\n\n        selectorDialog.close();\n        if (fastRoll && typeof onFastAuto === \"function\") {\n          try {\n            await onFastAuto({ actor, ability: chosen });\n          } catch (error) {\n            console.error(\"[tow-actions-lib-v1] onFastAuto callback failed.\", error);\n          }\n        }\n\n        await setupAbilityTestWithDamage(actor, chosen, { autoRoll: fastRoll });\n      });\n    }\n  });\n\n  selectorDialog.render(true);\n}\n");
})();
