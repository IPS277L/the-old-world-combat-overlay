// Auto-generated by macros/tools/build-overlay-runtime-libs.mjs
// Registers overlay runtime source part: 30-status-and-api
(() => {
  const bundle = game["towOverlayRuntimeBundleV1"] ?? (game["towOverlayRuntimeBundleV1"] = {
    version: "1.0.0",
    parts: new Map(),
    order: ["00-header-and-combat","10-layout-and-state","20-controls","30-status-and-api"]
  });
  bundle.version = "1.0.0";
  if (!(bundle.parts instanceof Map)) bundle.parts = new Map();
  bundle.parts.set("30-status-and-api", "function getIconSrc(displayObject) {\n  return (\n    displayObject?.texture?.baseTexture?.resource?.source?.src ||\n    displayObject?.texture?.baseTexture?.resource?.url ||\n    displayObject?.texture?.baseTexture?.resource?.src ||\n    \"\"\n  );\n}\n\nfunction normalizeIconSrc(src) {\n  return String(src ?? \"\").trim().toLowerCase().split(\"?\")[0];\n}\n\nfunction extractConditionIdFromSrc(src) {\n  const match = normalizeIconSrc(src).match(/\\/conditions\\/([a-z0-9_-]+)\\.svg$/);\n  return match?.[1] ?? null;\n}\n\nfunction getActorEffects(actor) {\n  return Array.from(actor?.effects?.contents ?? []);\n}\n\nfunction getEffectIconSrc(effect) {\n  return normalizeIconSrc(effect?.img ?? effect?.icon ?? \"\");\n}\n\nasync function runActorOpLock(actor, opKey, operation) {\n  const state = game[MODULE_KEY];\n  if (!state || !actor || !opKey || typeof operation !== \"function\") return;\n  if (!state.statusRemoveInFlight) state.statusRemoveInFlight = new Set();\n  const actorKey = actor.uuid ?? actor.id;\n  if (!actorKey) return;\n\n  const lockKey = `${actorKey}:${String(opKey)}`;\n  if (state.statusRemoveInFlight.has(lockKey)) return;\n  state.statusRemoveInFlight.add(lockKey);\n  try {\n    await operation();\n  } finally {\n    state.statusRemoveInFlight.delete(lockKey);\n  }\n}\n\nasync function setActorConditionState(actor, conditionId, active) {\n  if (!actor || !conditionId) return;\n  const id = String(conditionId);\n  const keepCustomFlow = id === \"staggered\";\n  if (!keepCustomFlow && typeof actor.toggleStatusEffect === \"function\") {\n    try {\n      await actor.toggleStatusEffect(id, { active });\n      return;\n    } catch (_error) {\n      // Fall back to system helpers if status effect registry lookup fails.\n    }\n  }\n\n  if (active) await actor.addCondition(id);\n  else await actor.removeCondition(id);\n}\n\nfunction getActorStatusSet(actor) {\n  const statuses = new Set(Array.from(actor?.statuses ?? []).map((s) => String(s)));\n  for (const effect of getActorEffects(actor)) {\n    for (const status of Array.from(effect?.statuses ?? [])) {\n      statuses.add(String(status));\n    }\n  }\n  return statuses;\n}\n\nfunction getAllConditionEntries() {\n  const conditions = game.oldworld?.config?.conditions ?? {};\n  return Object.entries(conditions)\n    .map(([id, data]) => ({\n      id: String(id),\n      img: String(data?.img ?? data?.icon ?? `/systems/whtow/assets/icons/conditions/${id}.svg`)\n    }))\n    .filter((entry) => !!entry.id && !!entry.img);\n}\n\nfunction getConditionTooltipData(conditionId) {\n  const condition = game.oldworld?.config?.conditions?.[String(conditionId ?? \"\")] ?? {};\n  const rawName = String(condition?.name ?? conditionId ?? \"Condition\");\n  const rawDescription = String(condition?.description ?? \"\");\n  const name = rawName.startsWith(\"TOW.\") ? game.i18n.localize(rawName) : rawName;\n  const localizedDescription = rawDescription.startsWith(\"TOW.\")\n    ? game.i18n.localize(rawDescription)\n    : rawDescription;\n  const shortDescription = localizedDescription\n    ? (localizedDescription.split(/(?<=[.!?])\\s+/)[0] ?? localizedDescription).trim()\n    : \"\";\n  return {\n    name: String(name ?? conditionId ?? \"Condition\"),\n    description: String(shortDescription ?? \"\")\n  };\n}\n\nfunction getTypeTooltipData(actor) {\n  const systemType = String(actor?.system?.type ?? \"\").trim().toLowerCase();\n  const fallbackType = String(actor?.type ?? \"actor\").trim().toLowerCase();\n  const typeKey = systemType || fallbackType;\n  const npcTypeLabelKey = game.oldworld?.config?.npcType?.[typeKey] ?? null;\n  const typeLabel = npcTypeLabelKey ? game.i18n.localize(npcTypeLabelKey) : getActorTypeLabel(actor);\n\n  if (typeKey === \"minion\") {\n    return { title: typeLabel, description: \"Minions are defeated at 1 wound.\" };\n  }\n  if ([\"brute\", \"champion\", \"monstrosity\"].includes(typeKey)) {\n    const cap = getMaxWoundLimit(actor);\n    const capText = Number.isFinite(cap) ? ` Defeated at ${cap} wounds.` : \"\";\n    return { title: typeLabel, description: `Threshold-based NPC type.${capText}` };\n  }\n  return { title: typeLabel, description: \"Actor type.\" };\n}\n\nfunction ensureStatusTooltip() {\n  const state = game[MODULE_KEY];\n  if (!state) return null;\n  if (state.statusTooltip?.element instanceof HTMLElement && state.statusTooltip.element.isConnected) return state.statusTooltip;\n\n  for (const stale of Array.from(document.querySelectorAll(`.${STATUS_TOOLTIP_DOM_CLASS}`))) {\n    stale.remove();\n  }\n\n  const element = document.createElement(\"div\");\n  element.classList.add(STATUS_TOOLTIP_DOM_CLASS);\n  element.style.position = \"fixed\";\n  element.style.left = \"0px\";\n  element.style.top = \"0px\";\n  element.style.display = \"none\";\n  element.style.pointerEvents = \"none\";\n  element.style.zIndex = \"10000\";\n  element.style.maxWidth = `${STATUS_TOOLTIP_MAX_WIDTH}px`;\n  element.style.padding = `${STATUS_TOOLTIP_PAD_Y}px ${STATUS_TOOLTIP_PAD_X}px`;\n  element.style.borderRadius = \"5px\";\n  element.style.border = `1px solid rgba(193, 139, 44, ${STATUS_TOOLTIP_BORDER_ALPHA})`;\n  element.style.background = \"rgba(15, 12, 9, 0.94)\";\n  element.style.color = \"#f2e7cc\";\n  element.style.fontFamily = \"var(--font-primary, Signika)\";\n  element.style.fontSize = `${STATUS_TOOLTIP_FONT_SIZE}px`;\n  element.style.fontWeight = \"400\";\n  element.style.lineHeight = \"1.3\";\n  element.style.whiteSpace = \"normal\";\n\n  const title = document.createElement(\"div\");\n  title.style.fontSize = `${STATUS_TOOLTIP_FONT_SIZE + 1}px`;\n  title.style.fontWeight = \"600\";\n  title.style.color = \"#fff4d8\";\n  title.style.marginBottom = \"3px\";\n\n  const body = document.createElement(\"div\");\n  body.style.fontSize = `${STATUS_TOOLTIP_FONT_SIZE}px`;\n  body.style.fontWeight = \"400\";\n  body.style.color = \"#f2e7cc\";\n\n  element.appendChild(title);\n  element.appendChild(body);\n  document.body.appendChild(element);\n  const view = canvas?.app?.renderer?.events?.domElement ?? canvas?.app?.view ?? null;\n  const hideOnLeave = () => hideStatusTooltip();\n  const hideOnBlur = () => hideStatusTooltip();\n  const hideOnPointerDown = () => hideStatusTooltip();\n  const hideOnKeyDown = () => hideStatusTooltip();\n  if (view?.addEventListener) view.addEventListener(\"mouseleave\", hideOnLeave);\n  window.addEventListener(\"blur\", hideOnBlur);\n  window.addEventListener(\"pointerdown\", hideOnPointerDown, true);\n  window.addEventListener(\"keydown\", hideOnKeyDown, true);\n\n  state.statusTooltip = { element, title, body, view, hideOnLeave, hideOnBlur, hideOnPointerDown, hideOnKeyDown };\n  return state.statusTooltip;\n}\n\nfunction showOverlayTooltip(title, description, point, existingTooltip = null) {\n  const tooltip = existingTooltip ?? ensureStatusTooltip();\n  if (!tooltip || !point) return;\n  tooltip.title.textContent = String(title ?? \"\");\n  tooltip.body.textContent = String(description ?? \"\");\n\n  const view = canvas?.app?.renderer?.events?.domElement ?? canvas?.app?.view;\n  const rect = view?.getBoundingClientRect?.();\n  const clientX = Number(point.x ?? 0) + Number(rect?.left ?? 0) + STATUS_TOOLTIP_OFFSET_X;\n  const clientY = Number(point.y ?? 0) + Number(rect?.top ?? 0) + STATUS_TOOLTIP_OFFSET_Y;\n\n  // Prevent showing canvas overlay tooltips when another UI element is on top (e.g. actor sheet).\n  const topElement = document.elementFromPoint(clientX, clientY);\n  const cursorOnCanvas = !!(view && topElement && (topElement === view || view.contains(topElement)));\n  if (!cursorOnCanvas) {\n    hideStatusTooltip();\n    return;\n  }\n\n  tooltip.element.style.left = `${Math.round(clientX)}px`;\n  tooltip.element.style.top = `${Math.round(clientY)}px`;\n  tooltip.element.style.display = \"block\";\n}\n\nfunction hideStatusTooltip() {\n  for (const element of Array.from(document.querySelectorAll(`.${STATUS_TOOLTIP_DOM_CLASS}`))) {\n    if (element instanceof HTMLElement) element.style.display = \"none\";\n  }\n  const state = game[MODULE_KEY];\n  const element = state?.statusTooltip?.element;\n  if (element instanceof HTMLElement) element.style.display = \"none\";\n}\n\nfunction clearStatusTooltip() {\n  const state = game[MODULE_KEY];\n  if (!state?.statusTooltip) return;\n  const view = state.statusTooltip.view;\n  const hideOnLeave = state.statusTooltip.hideOnLeave;\n  const hideOnBlur = state.statusTooltip.hideOnBlur;\n  const hideOnPointerDown = state.statusTooltip.hideOnPointerDown;\n  const hideOnKeyDown = state.statusTooltip.hideOnKeyDown;\n  if (view?.removeEventListener && hideOnLeave) view.removeEventListener(\"mouseleave\", hideOnLeave);\n  if (hideOnBlur) window.removeEventListener(\"blur\", hideOnBlur);\n  if (hideOnPointerDown) window.removeEventListener(\"pointerdown\", hideOnPointerDown, true);\n  if (hideOnKeyDown) window.removeEventListener(\"keydown\", hideOnKeyDown, true);\n  const element = state.statusTooltip.element;\n  if (element instanceof HTMLElement) element.remove();\n  for (const stale of Array.from(document.querySelectorAll(`.${STATUS_TOOLTIP_DOM_CLASS}`))) {\n    stale.remove();\n  }\n  delete state.statusTooltip;\n}\n\nfunction resolveEffectFromIcon(actor, sprite) {\n  const spriteSrc = normalizeIconSrc(getIconSrc(sprite));\n  if (!spriteSrc) return null;\n  return getActorEffects(actor).find((effect) => getEffectIconSrc(effect) === spriteSrc) ?? null;\n}\n\nasync function removeStatusIconEffect(tokenObject, sprite) {\n  const actor = getActorFromToken(tokenObject);\n  if (!actor) return;\n  if (!canEditActor(actor)) {\n    warnNoPermission(actor);\n    return;\n  }\n\n  const effect = resolveEffectFromIcon(actor, sprite);\n  const conditionId = extractConditionIdFromSrc(getIconSrc(sprite));\n  const removeKey = effect?.id ?? conditionId ?? normalizeIconSrc(getIconSrc(sprite));\n  if (!removeKey) return;\n\n  await runActorOpLock(actor, `remove:${removeKey}`, async () => {\n    if (effect) {\n      if (actor.effects?.has?.(effect.id)) await effect.delete();\n    } else if (conditionId && actor.hasCondition?.(conditionId)) {\n      await setActorConditionState(actor, conditionId, false);\n    }\n  });\n}\n\nfunction clearStatusIconHandler(sprite) {\n  const handler = sprite?.[KEYS.statusIconHandler];\n  if (handler) {\n    sprite.off(\"pointerdown\", handler);\n    sprite.off(\"contextmenu\", handler);\n    delete sprite[KEYS.statusIconHandler];\n  }\n  const overHandler = sprite?.[KEYS.statusIconTooltipOverHandler];\n  if (overHandler) {\n    sprite.off(\"pointerover\", overHandler);\n    delete sprite[KEYS.statusIconTooltipOverHandler];\n  }\n  const moveHandler = sprite?.[KEYS.statusIconTooltipMoveHandler];\n  if (moveHandler) {\n    sprite.off(\"pointermove\", moveHandler);\n    delete sprite[KEYS.statusIconTooltipMoveHandler];\n  }\n  const outHandler = sprite?.[KEYS.statusIconTooltipOutHandler];\n  if (outHandler) {\n    sprite.off(\"pointerout\", outHandler);\n    sprite.off(\"pointerupoutside\", outHandler);\n    sprite.off(\"pointercancel\", outHandler);\n    delete sprite[KEYS.statusIconTooltipOutHandler];\n  }\n}\n\nfunction clearStatusPalette(tokenObject) {\n  const layer = tokenObject?.[KEYS.statusPaletteLayer];\n  if (!layer) return;\n  for (const child of layer.children ?? []) clearStatusIconHandler(child);\n  layer.removeChildren().forEach((child) => child.destroy());\n  layer.parent?.removeChild(layer);\n  layer.destroy();\n  delete tokenObject[KEYS.statusPaletteLayer];\n  delete tokenObject[KEYS.statusPaletteMetrics];\n}\n\nfunction hideDefaultStatusPanel(tokenObject) {\n  const effects = tokenObject?.effects;\n  if (!effects) return;\n  if (typeof tokenObject[KEYS.defaultEffectsVisible] === \"undefined\") {\n    tokenObject[KEYS.defaultEffectsVisible] = effects.visible !== false;\n  }\n  effects.visible = false;\n}\n\nfunction restoreDefaultStatusPanel(tokenObject) {\n  const effects = tokenObject?.effects;\n  if (!effects) return;\n  const prior = tokenObject[KEYS.defaultEffectsVisible];\n  effects.visible = (typeof prior === \"boolean\") ? prior : true;\n  delete tokenObject[KEYS.defaultEffectsVisible];\n}\n\nfunction hideCoreTokenHoverVisuals(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const tooltip = tokenObject?.tooltip ?? null;\n  if (tooltip) {\n    if (typeof tokenObject[KEYS.coreTooltipVisible] === \"undefined\") {\n      tokenObject[KEYS.coreTooltipVisible] = tooltip.visible !== false;\n    }\n    if (typeof tokenObject[KEYS.coreTooltipRenderable] === \"undefined\") {\n      tokenObject[KEYS.coreTooltipRenderable] = tooltip.renderable !== false;\n    }\n    tooltip.visible = false;\n    tooltip.renderable = false;\n  }\n\n  const nameplate = tokenObject?.nameplate ?? null;\n  if (nameplate) {\n    if (typeof tokenObject[KEYS.coreNameplateVisible] === \"undefined\") {\n      tokenObject[KEYS.coreNameplateVisible] = nameplate.visible !== false;\n    }\n    if (typeof tokenObject[KEYS.coreNameplateRenderable] === \"undefined\") {\n      tokenObject[KEYS.coreNameplateRenderable] = nameplate.renderable !== false;\n    }\n    nameplate.visible = false;\n    nameplate.renderable = false;\n  }\n\n  const border = tokenObject.border ?? null;\n  if (border) {\n    if (typeof tokenObject[KEYS.coreBorderVisible] === \"undefined\") {\n      tokenObject[KEYS.coreBorderVisible] = border.visible !== false;\n    }\n    if (typeof tokenObject[KEYS.coreBorderAlpha] === \"undefined\") {\n      tokenObject[KEYS.coreBorderAlpha] = Number(border.alpha ?? 1);\n    }\n    border.visible = false;\n    if (\"alpha\" in border) border.alpha = 0;\n  }\n}\n\nfunction restoreCoreTokenHoverVisuals(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const tooltip = tokenObject?.tooltip ?? null;\n  if (tooltip && typeof tokenObject[KEYS.coreTooltipVisible] === \"boolean\") {\n    tooltip.visible = tokenObject[KEYS.coreTooltipVisible];\n  }\n  if (tooltip && typeof tokenObject[KEYS.coreTooltipRenderable] === \"boolean\") {\n    tooltip.renderable = tokenObject[KEYS.coreTooltipRenderable];\n  }\n  delete tokenObject[KEYS.coreTooltipVisible];\n  delete tokenObject[KEYS.coreTooltipRenderable];\n\n  const nameplate = tokenObject?.nameplate ?? null;\n  if (nameplate && typeof tokenObject[KEYS.coreNameplateVisible] === \"boolean\") {\n    nameplate.visible = tokenObject[KEYS.coreNameplateVisible];\n  }\n  if (nameplate && typeof tokenObject[KEYS.coreNameplateRenderable] === \"boolean\") {\n    nameplate.renderable = tokenObject[KEYS.coreNameplateRenderable];\n  }\n  delete tokenObject[KEYS.coreNameplateVisible];\n  delete tokenObject[KEYS.coreNameplateRenderable];\n\n  const border = tokenObject.border ?? null;\n  if (border && typeof tokenObject[KEYS.coreBorderVisible] === \"boolean\") {\n    border.visible = tokenObject[KEYS.coreBorderVisible];\n  }\n  if (border && typeof tokenObject[KEYS.coreBorderAlpha] === \"number\" && \"alpha\" in border) {\n    border.alpha = tokenObject[KEYS.coreBorderAlpha];\n  }\n  delete tokenObject[KEYS.coreBorderVisible];\n  delete tokenObject[KEYS.coreBorderAlpha];\n}\n\nasync function toggleConditionFromPalette(actor, conditionId) {\n  if (!actor || !conditionId) return;\n  if (!canEditActor(actor)) {\n    warnNoPermission(actor);\n    return;\n  }\n  const hasCondition = !!actor.hasCondition?.(conditionId);\n  if (hasCondition) {\n    await runActorOpLock(actor, `condition:${conditionId}`, async () => {\n      if (!actor.hasCondition?.(conditionId)) return;\n      await setActorConditionState(actor, conditionId, false);\n    });\n  } else {\n    await runActorOpLock(actor, `condition:${conditionId}`, async () => {\n      if (actor.hasCondition?.(conditionId)) return;\n      await setActorConditionState(actor, conditionId, true);\n    });\n  }\n}\n\nfunction stylePaletteSprite(sprite, actor, conditionId, activeStatuses = null) {\n  const statuses = activeStatuses instanceof Set ? activeStatuses : getActorStatusSet(actor);\n  const active = statuses.has(String(conditionId ?? \"\"));\n  const key = String(conditionId ?? \"\").toLowerCase();\n  const iconSrc = normalizeIconSrc(getIconSrc(sprite));\n  const conditionImgSrc = normalizeIconSrc(sprite?._towConditionImg ?? \"\");\n  const specialKind = (() => {\n    if (key.includes(\"stagger\")) return \"staggered\";\n    if (key.includes(\"dead\")) return \"dead\";\n    if (conditionImgSrc.includes(\"/conditions/staggered.svg\")) return \"staggered\";\n    if (conditionImgSrc.includes(\"/conditions/dead.svg\")) return \"dead\";\n    if (iconSrc.includes(\"/conditions/staggered.svg\")) return \"staggered\";\n    if (iconSrc.includes(\"/conditions/dead.svg\")) return \"dead\";\n    return null;\n  })();\n  const clearLegacySpecials = () => {\n    const ring = sprite._towPaletteRing;\n    if (ring) {\n      ring.parent?.removeChild(ring);\n      ring.destroy();\n      delete sprite._towPaletteRing;\n    }\n    const filter = sprite._towPaletteFilter;\n    if (filter) {\n      filter.destroy?.();\n      delete sprite._towPaletteFilter;\n    }\n    delete sprite._towPaletteFilterKind;\n    sprite.filters = null;\n  };\n\n  const clearSpecialBg = () => {\n    const bg = sprite._towPaletteBg;\n    if (!bg) return;\n    bg.parent?.removeChild(bg);\n    bg.destroy();\n    delete sprite._towPaletteBg;\n  };\n\n  const applySpecialBg = (color, alpha) => {\n    let bg = sprite._towPaletteBg;\n    if (!bg || bg.destroyed) {\n      bg = new PIXI.Graphics();\n      bg.eventMode = \"none\";\n      bg._towPaletteHelper = true;\n      sprite._towPaletteBg = bg;\n      sprite.parent?.addChildAt(bg, 0);\n    } else if (bg.parent !== sprite.parent) {\n      bg.parent?.removeChild(bg);\n      sprite.parent?.addChildAt(bg, 0);\n    }\n    const size = Number.isFinite(Number(sprite._towIconSize)) ? Number(sprite._towIconSize) : STATUS_PALETTE_ICON_SIZE;\n    const pad = STATUS_PALETTE_SPECIAL_BG_PAD;\n    bg.clear();\n    bg.lineStyle({\n      width: STATUS_PALETTE_SPECIAL_BG_OUTLINE_WIDTH,\n      color: STATUS_PALETTE_SPECIAL_BG_OUTLINE,\n      alpha: STATUS_PALETTE_SPECIAL_BG_OUTLINE_ALPHA,\n      alignment: 0.5\n    });\n    bg.beginFill(color, alpha);\n    bg.drawRoundedRect(\n      sprite.x - pad,\n      sprite.y - pad,\n      Math.max(2, size + (pad * 2)),\n      Math.max(2, size + (pad * 2)),\n      STATUS_PALETTE_SPECIAL_BG_RADIUS\n    );\n    bg.endFill();\n  };\n\n  if (!active) {\n    sprite.tint = STATUS_PALETTE_INACTIVE_TINT;\n    sprite.alpha = 0.40;\n    clearLegacySpecials();\n    clearSpecialBg();\n    return;\n  }\n\n  clearLegacySpecials();\n  sprite.alpha = 0.98;\n\n  if (specialKind === \"staggered\") {\n    sprite.tint = STATUS_PALETTE_ACTIVE_TINT;\n    applySpecialBg(STATUS_PALETTE_STAGGERED_RING, STATUS_PALETTE_SPECIAL_BG_STAGGERED_ALPHA);\n    return;\n  }\n\n  if (specialKind === \"dead\") {\n    sprite.tint = STATUS_PALETTE_ACTIVE_TINT;\n    applySpecialBg(STATUS_PALETTE_DEAD_RING, STATUS_PALETTE_SPECIAL_BG_DEAD_ALPHA);\n    return;\n  }\n\n  sprite.tint = STATUS_PALETTE_ACTIVE_TINT;\n  clearSpecialBg();\n}\n\nfunction setupStatusPalette(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const actor = getActorFromToken(tokenObject);\n  if (!actor) return;\n\n  const conditions = getAllConditionEntries();\n  if (!conditions.length) {\n    clearStatusPalette(tokenObject);\n    return;\n  }\n\n  const expectedCount = conditions.length;\n  const iconSize = STATUS_PALETTE_ICON_SIZE;\n  let layer = tokenObject[KEYS.statusPaletteLayer];\n  const shouldRebuild = !layer\n    || layer.destroyed\n    || layer.parent !== tokenObject\n    || (layer.children?.length ?? 0) !== expectedCount\n    || tokenObject[KEYS.statusPaletteMetrics]?.iconSize !== iconSize;\n\n  if (shouldRebuild) {\n    clearStatusPalette(tokenObject);\n    layer = new PIXI.Container();\n    layer.eventMode = \"static\";\n    layer.interactive = true;\n    layer.interactiveChildren = true;\n    layer[KEYS.statusPaletteMarker] = true;\n    layer[KEYS.statusPaletteTokenId] = tokenObject.id;\n    tokenObject.addChild(layer);\n    tokenObject[KEYS.statusPaletteLayer] = layer;\n\n    const columns = Math.max(1, Math.ceil(expectedCount / STATUS_PALETTE_ROWS));\n    for (let i = 0; i < conditions.length; i++) {\n      const condition = conditions[i];\n      const sprite = PIXI.Sprite.from(condition.img);\n      sprite.width = iconSize;\n      sprite.height = iconSize;\n      sprite.eventMode = \"static\";\n      sprite.interactive = true;\n      sprite.cursor = canEditActor(actor) ? \"pointer\" : \"default\";\n      sprite._towConditionId = condition.id;\n      sprite._towConditionImg = condition.img;\n      sprite._towIconSize = iconSize;\n\n      const col = i % columns;\n      const row = Math.floor(i / columns);\n      sprite.position.set(\n        col * (iconSize + STATUS_PALETTE_ICON_GAP),\n        row * (iconSize + STATUS_PALETTE_ICON_GAP)\n      );\n\n      const onDown = async (event) => {\n        preventPointerDefault(event);\n        if (getMouseButton(event) !== 0) return;\n        await toggleConditionFromPalette(actor, condition.id);\n      };\n      sprite.on(\"pointerdown\", onDown);\n      sprite[KEYS.statusIconHandler] = onDown;\n      bindTooltipHandlers(\n        sprite,\n        () => getConditionTooltipData(condition.id),\n        {\n          over: KEYS.statusIconTooltipOverHandler,\n          move: KEYS.statusIconTooltipMoveHandler,\n          out: KEYS.statusIconTooltipOutHandler\n        }\n      );\n\n      layer.addChild(sprite);\n    }\n    tokenObject[KEYS.statusPaletteMetrics] = { iconSize };\n  }\n\n  const columns = Math.max(1, Math.ceil(expectedCount / STATUS_PALETTE_ROWS));\n  const totalRows = Math.ceil(expectedCount / columns);\n  const totalWidth = (columns * iconSize) + ((columns - 1) * STATUS_PALETTE_ICON_GAP);\n  const totalHeight = (totalRows * iconSize) + ((totalRows - 1) * STATUS_PALETTE_ICON_GAP);\n  const posX = Math.round((tokenObject.w - totalWidth) / 2);\n  const posY = Math.round(tokenObject.h + STATUS_PALETTE_TOKEN_PAD);\n  layer.position.set(posX, posY);\n  layer.visible = tokenObject.visible;\n  const activeStatuses = getActorStatusSet(actor);\n\n  for (const sprite of layer.children?.filter((child) => child?._towConditionId) ?? []) {\n    sprite.cursor = canEditActor(actor) ? \"pointer\" : \"default\";\n    stylePaletteSprite(sprite, actor, sprite._towConditionId, activeStatuses);\n  }\n}\n\nfunction clearAllStatusOverlays() {\n  hideStatusTooltip();\n  forEachSceneToken((token) => {\n    for (const sprite of token.effects?.children ?? []) clearStatusIconHandler(sprite);\n    clearStatusPalette(token);\n    restoreDefaultStatusPanel(token);\n    restoreCoreTokenHoverVisuals(token);\n    clearDeadVisual(token);\n    restoreTokenOverlayInteractivity(token);\n    clearCustomLayoutBorder(token);\n  });\n\n  const orphaned = [];\n  for (const child of canvas.tokens.children ?? []) {\n    if (child?.[KEYS.statusPaletteMarker] === true) orphaned.push(child);\n  }\n  for (const layer of orphaned) clearDisplayObject(layer);\n  clearStatusTooltip();\n}\n\nfunction refreshTokenOverlay(tokenObject) {\n  primeDeadPresence(getActorFromToken(tokenObject));\n  ensureTokenOverlayInteractivity(tokenObject);\n  hideDefaultStatusPanel(tokenObject);\n  hideCoreTokenHoverVisuals(tokenObject);\n  setupStatusPalette(tokenObject);\n  updateWoundControlUI(tokenObject);\n  updateNameLabel(tokenObject);\n  updateResilienceLabel(tokenObject);\n  updateTokenOverlayHitArea(tokenObject);\n  updateCustomLayoutBorderVisibility(tokenObject);\n  ensureDeadVisual(tokenObject);\n}\n\nfunction refreshActorOverlays(actor) {\n  primeDeadPresence(actor);\n  queueWoundSyncFromDeadState(actor);\n  for (const tokenObject of getActorTokenObjects(actor)) {\n    refreshTokenOverlay(tokenObject);\n  }\n}\n\nfunction queueActorOverlayResync(actor) {\n  if (!actor) return;\n  const state = game[MODULE_KEY];\n  if (!state) return;\n  if (!state.actorOverlayResyncTimers) state.actorOverlayResyncTimers = new Map();\n\n  const key = actor.uuid ?? actor.id;\n  if (!key) return;\n\n  const existing = state.actorOverlayResyncTimers.get(key);\n  if (Array.isArray(existing)) {\n    for (const timer of existing) clearTimeout(timer);\n  }\n\n  const timers = ACTOR_OVERLAY_RESYNC_DELAYS_MS.map((delayMs) => setTimeout(() => {\n    refreshActorOverlays(actor);\n  }, delayMs));\n  state.actorOverlayResyncTimers.set(key, timers);\n}\n\nfunction refreshAllOverlays() {\n  forEachSceneToken((token) => {\n    refreshTokenOverlay(token);\n  });\n}\n\nfunction registerHooks() {\n  return {\n    canvasReady: Hooks.on(\"canvasReady\", refreshAllOverlays),\n    canvasPan: Hooks.on(\"canvasPan\", (_canvas, viewPosition) => {\n      const state = game[MODULE_KEY];\n      if (!state) return;\n      const nextScale = Number(viewPosition?.scale ?? canvas?.stage?.scale?.x ?? 1);\n      const lastScale = Number(state.lastCanvasScale ?? NaN);\n      if (Number.isFinite(lastScale) && Math.abs(nextScale - lastScale) < 0.01) return;\n      state.lastCanvasScale = nextScale;\n      refreshAllOverlays();\n    }),\n    refreshToken: Hooks.on(\"refreshToken\", (token) => refreshTokenOverlay(token)),\n    hoverToken: Hooks.on(\"hoverToken\", (token, hovered) => {\n      hideCoreTokenHoverVisuals(token);\n      updateCustomLayoutBorderVisibility(token, { hovered });\n    }),\n    controlToken: Hooks.on(\"controlToken\", (token, controlled) => {\n      if (controlled) void bringTokenToFront(token);\n      hideCoreTokenHoverVisuals(token);\n      updateCustomLayoutBorderVisibility(token, { controlled });\n    }),\n    createItem: Hooks.on(\"createItem\", (item) => {\n      if (item.type !== WOUND_ITEM_TYPE) return;\n      refreshActorOverlays(item.parent);\n      queueActorOverlayResync(item.parent);\n      queueDeadSyncFromWounds(item.parent);\n    }),\n    updateItem: Hooks.on(\"updateItem\", (item) => {\n      if (item.type !== WOUND_ITEM_TYPE) return;\n      refreshActorOverlays(item.parent);\n      queueActorOverlayResync(item.parent);\n      queueDeadSyncFromWounds(item.parent);\n    }),\n    deleteItem: Hooks.on(\"deleteItem\", (item) => {\n      if (item.type !== WOUND_ITEM_TYPE) return;\n      refreshActorOverlays(item.parent);\n      queueActorOverlayResync(item.parent);\n      queueDeadSyncFromWounds(item.parent);\n    }),\n    createActiveEffect: Hooks.on(\"createActiveEffect\", (effect) => refreshActorOverlays(effect?.parent)),\n    updateActiveEffect: Hooks.on(\"updateActiveEffect\", (effect) => refreshActorOverlays(effect?.parent)),\n    deleteActiveEffect: Hooks.on(\"deleteActiveEffect\", (effect) => refreshActorOverlays(effect?.parent))\n  };\n}\n\nfunction unregisterHooks(hookIds) {\n  Hooks.off(\"canvasReady\", hookIds.canvasReady);\n  Hooks.off(\"canvasPan\", hookIds.canvasPan);\n  Hooks.off(\"refreshToken\", hookIds.refreshToken);\n  Hooks.off(\"hoverToken\", hookIds.hoverToken);\n  Hooks.off(\"controlToken\", hookIds.controlToken);\n  Hooks.off(\"createItem\", hookIds.createItem);\n  Hooks.off(\"updateItem\", hookIds.updateItem);\n  Hooks.off(\"deleteItem\", hookIds.deleteItem);\n  Hooks.off(\"createActiveEffect\", hookIds.createActiveEffect);\n  Hooks.off(\"updateActiveEffect\", hookIds.updateActiveEffect);\n  Hooks.off(\"deleteActiveEffect\", hookIds.deleteActiveEffect);\n}\n\n\nfunction isOverlayEnabled() {\n  return !!game[MODULE_KEY];\n}\n\nfunction enableOverlay() {\n  if (game[MODULE_KEY]) return false;\n  game[MODULE_KEY] = {\n    ...registerHooks(),\n    recentAttacks: new Map(),\n    recentTargets: new Map(),\n    autoApplyArmed: new Set(),\n    actorOverlayResyncTimers: new Map(),\n    deadSyncTimers: new Map(),\n    deadToWoundSyncTimers: new Map(),\n    deadPresenceByActor: new Map(),\n    deadSyncInFlight: new Set(),\n    statusRemoveInFlight: new Set(),\n    lastCanvasScale: Number(canvas?.stage?.scale?.x ?? 1)\n  };\n  refreshAllOverlays();\n  ui.notifications.info(\"Overlay enabled: wounds + resilience + status highlights.\");\n  return true;\n}\n\nfunction disableOverlay() {\n  const state = game[MODULE_KEY];\n  if (!state) return false;\n  unregisterHooks(state);\n  if (state?.actorOverlayResyncTimers instanceof Map) {\n    for (const timers of state.actorOverlayResyncTimers.values()) {\n      if (!Array.isArray(timers)) continue;\n      for (const timer of timers) clearTimeout(timer);\n    }\n    state.actorOverlayResyncTimers.clear();\n  }\n  if (state?.deadSyncTimers instanceof Map) {\n    for (const entry of state.deadSyncTimers.values()) {\n      if (typeof entry?.cancel === \"function\") entry.cancel();\n      else clearTimeout(entry);\n    }\n    state.deadSyncTimers.clear();\n  }\n  if (state?.deadToWoundSyncTimers instanceof Map) {\n    for (const entry of state.deadToWoundSyncTimers.values()) {\n      if (typeof entry?.cancel === \"function\") entry.cancel();\n      else clearTimeout(entry);\n    }\n    state.deadToWoundSyncTimers.clear();\n  }\n  if (state?.deadPresenceByActor instanceof Map) state.deadPresenceByActor.clear();\n  if (state?.deadSyncInFlight instanceof Set) state.deadSyncInFlight.clear();\n  if (state?.staggerWaitPatch && typeof foundry.applications?.api?.Dialog?.wait === \"function\") {\n    foundry.applications.api.Dialog.wait = state.staggerWaitPatch.originalWait;\n  }\n  delete game[MODULE_KEY];\n\n  clearAllWoundControls();\n  clearAllNameLabels();\n  clearAllResilienceLabels();\n  clearAllStatusOverlays();\n  ui.notifications.info(\"Overlay disabled.\");\n  return true;\n}\n\nfunction toggleOverlay() {\n  return isOverlayEnabled() ? disableOverlay() : enableOverlay();\n}\n\nconst TOW_OVERLAY_API_KEY = \"towOverlay\";\nconst TOW_OVERLAY_VERSION = \"1.0.0\";\n\nconst api = game[TOW_OVERLAY_API_KEY] ?? {};\ngame[TOW_OVERLAY_API_KEY] = {\n  ...api,\n  version: TOW_OVERLAY_VERSION,\n  isEnabled: isOverlayEnabled,\n  enable: enableOverlay,\n  disable: disableOverlay,\n  toggle: toggleOverlay,\n  refreshAll: refreshAllOverlays,\n  refreshActor: refreshActorOverlays,\n  refreshToken: refreshTokenOverlay\n};\n");
})();
