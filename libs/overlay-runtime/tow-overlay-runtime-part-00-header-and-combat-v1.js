// Auto-generated by macros/tools/build-overlay-runtime-libs.mjs
// Registers overlay runtime source part: 00-header-and-combat
(() => {
  const bundle = game["towOverlayRuntimeBundleV1"] ?? (game["towOverlayRuntimeBundleV1"] = {
    version: "1.0.0",
    parts: new Map(),
    order: ["00-header-and-combat","10-layout-and-state","20-controls","30-status-and-api"]
  });
  bundle.version = "1.0.0";
  if (!(bundle.parts instanceof Map)) bundle.parts = new Map();
  bundle.parts.set("00-header-and-combat", "// Toggle Overlay (Foundry V13)\n// Combines:\n// 1) Wound controls (W left click add, right click remove)\n// 2) STAG text toggle control\n// 3) RES label above token\n// 4) Status icon backgrounds (yellow staggered, gray dead)\n\nconst MODULE_KEY = \"towMacroToggleOverlay\";\nconst PreciseTextClass = foundry.canvas.containers.PreciseText;\nconst LIB_MACRO_CANDIDATES = [\"tow-actions-lib-v1\", \"tow-actions-lib\"];\nconst ACTIONS_RUNTIME_PARTS = [\n  \"tow-actions-runtime-part-00-core-v1\",\n  \"tow-actions-runtime-part-10-attack-flow-v1\",\n  \"tow-actions-runtime-part-20-defence-flow-v1\",\n  \"tow-actions-runtime-part-30-api-v1\"\n];\nconst ACTIONS_RUNTIME_LOADER_CANDIDATES = [\"tow-actions-runtime-loader-v1\"];\n\nconst KEYS = {\n  woundUI: \"_towWoundControlUI\",\n  woundUiMarker: \"_towOverlayWoundUiMarker\",\n  woundUiTokenId: \"_towOverlayWoundUiTokenId\",\n  nameLabel: \"_towNameLabel\",\n  nameLabelMarker: \"_towOverlayNameLabelMarker\",\n  nameLabelTokenId: \"_towOverlayNameLabelTokenId\",\n  resilienceLabel: \"_towResilienceLabel\",\n  defaultEffectsVisible: \"_towDefaultEffectsVisible\",\n  statusPaletteLayer: \"_towStatusPaletteLayer\",\n  statusPaletteMarker: \"_towOverlayStatusPaletteMarker\",\n  statusPaletteTokenId: \"_towOverlayStatusPaletteTokenId\",\n  statusPaletteMetrics: \"_towStatusPaletteMetrics\",\n  deadVisualState: \"_towDeadVisualState\",\n  statusIconHandler: \"_towStatusIconHandler\",\n  statusIconTooltipOverHandler: \"_towStatusIconTooltipOverHandler\",\n  statusIconTooltipMoveHandler: \"_towStatusIconTooltipMoveHandler\",\n  statusIconTooltipOutHandler: \"_towStatusIconTooltipOutHandler\",\n  tokenInteractiveChildrenOriginal: \"_towTokenInteractiveChildrenOriginal\",\n  tokenHitAreaOriginal: \"_towTokenHitAreaOriginal\",\n  coreTooltipVisible: \"_towCoreTooltipVisible\",\n  coreTooltipRenderable: \"_towCoreTooltipRenderable\",\n  coreNameplateVisible: \"_towCoreNameplateVisible\",\n  coreNameplateRenderable: \"_towCoreNameplateRenderable\",\n  coreBorderVisible: \"_towCoreBorderVisible\",\n  coreBorderAlpha: \"_towCoreBorderAlpha\",\n  layoutBorder: \"_towLayoutBorder\",\n  layoutBounds: \"_towLayoutBounds\"\n};\n\nconst STATUS_PALETTE_ICON_SIZE = 20;\nconst STATUS_PALETTE_ICON_GAP = 2;\nconst STATUS_PALETTE_ROWS = 2;\nconst TOKEN_CONTROL_PAD = 6;\nconst NAME_TYPE_STACK_OVERLAP_PX = 13;\nconst NAME_TYPE_TO_TOKEN_OFFSET_PX = 6;\nconst STATUS_PALETTE_TOKEN_PAD = TOKEN_CONTROL_PAD;\nconst STATUS_PALETTE_INACTIVE_TINT = 0x7A7A7A;\nconst STATUS_PALETTE_ACTIVE_TINT = 0xFFFFFF;\nconst STATUS_PALETTE_STAGGERED_RING = 0xFFD54A;\nconst STATUS_PALETTE_DEAD_RING = 0xFFFFFF;\nconst STATUS_PALETTE_SPECIAL_BG_PAD = 1;\nconst STATUS_PALETTE_SPECIAL_BG_RADIUS = 3;\nconst STATUS_PALETTE_SPECIAL_BG_OUTLINE = 0x171717;\nconst STATUS_PALETTE_SPECIAL_BG_OUTLINE_WIDTH = 1;\nconst STATUS_PALETTE_SPECIAL_BG_OUTLINE_ALPHA = 0.72;\nconst STATUS_PALETTE_SPECIAL_BG_STAGGERED_ALPHA = 0.58;\nconst STATUS_PALETTE_SPECIAL_BG_DEAD_ALPHA = 0.62;\nconst LAYOUT_BORDER_COLOR = 0xE39A1A;\nconst LAYOUT_BORDER_ALPHA = 1;\nconst LAYOUT_BORDER_WIDTH = 2;\nconst LAYOUT_BORDER_RADIUS = 6;\nconst OVERLAY_FONT_SIZE = 22;\nconst DRAG_START_THRESHOLD_PX = 8;\nconst DRAG_LINE_OUTER_COLOR = 0x1A0909;\nconst DRAG_LINE_OUTER_ALPHA = 0.85;\nconst DRAG_LINE_OUTER_WIDTH = 7;\nconst DRAG_LINE_INNER_COLOR = 0x8F2A2A;\nconst DRAG_LINE_INNER_ALPHA = 0.96;\nconst DRAG_LINE_INNER_WIDTH = 3;\nconst DRAG_ARROW_SIZE = 13;\nconst DRAG_ENDPOINT_OUTER_RADIUS = 6;\nconst DRAG_ENDPOINT_RING_WIDTH = 2;\nconst ATTACK_DEDUPE_WINDOW_MS = 700;\nconst TARGET_DEDUPE_WINDOW_MS = 300;\nconst AUTO_DEFENCE_WAIT_MS = 4000;\nconst AUTO_APPLY_WAIT_MS = 10000;\nconst OPPOSED_LINK_WAIT_MS = 700;\nconst AUTO_STAGGER_PATCH_MS = 12000;\nconst FLOW_CARD_FONT_SIZE = \"var(--font-size-16)\";\nconst FLOW_CARD_CHIP_FONT_SIZE = \"var(--font-size-12)\";\nconst ACTOR_OVERLAY_RESYNC_DELAYS_MS = [50, 180];\nconst DEAD_SYNC_DEBOUNCE_MS = 60;\nconst DEAD_TO_WOUND_SYNC_DEBOUNCE_MS = 80;\nconst STATUS_TOOLTIP_FONT_SIZE = 14;\nconst STATUS_TOOLTIP_MAX_WIDTH = 260;\nconst STATUS_TOOLTIP_PAD_X = 8;\nconst STATUS_TOOLTIP_PAD_Y = 6;\nconst STATUS_TOOLTIP_OFFSET_X = 12;\nconst STATUS_TOOLTIP_OFFSET_Y = 12;\nconst STATUS_TOOLTIP_BG_COLOR = 0x0F0C09;\nconst STATUS_TOOLTIP_BG_ALPHA = 0.94;\nconst STATUS_TOOLTIP_BORDER_COLOR = 0xC18B2C;\nconst STATUS_TOOLTIP_BORDER_ALPHA = 0.9;\nconst STATUS_TOOLTIP_DOM_CLASS = \"tow-overlay-status-tooltip\";\nconst OVERLAY_TEXT_RESOLUTION_MIN = 3;\nconst OVERLAY_TEXT_RESOLUTION_MAX = 8;\nconst OVERLAY_CONTROL_ICON_TINT = 0xFFF4D8;\nconst OVERLAY_CONTROL_ICON_OUTLINE_COLOR = 0x2A2620;\nconst OVERLAY_CONTROL_ICON_OUTLINE_THICKNESS = 1.4;\nconst OVERLAY_CONTROL_ICON_OUTLINE_ALPHA = 0.58;\n\nconst WOUND_ITEM_TYPE = \"wound\";\nconst ICON_SRC_ATK = \"icons/svg/sword.svg\";\nconst ICON_SRC_DEF = \"icons/svg/shield.svg\";\nconst ICON_SRC_WOUND = \"icons/svg/blood.svg\";\nconst ICON_SRC_RES = \"icons/svg/statue.svg\";\n\nfunction canEditActor(actor) {\n  return actor?.isOwner === true;\n}\n\nfunction warnNoPermission(actor) {\n  ui.notifications.warn(`No permission to edit ${actor?.name ?? \"actor\"}.`);\n}\n\nfunction getActorFromToken(tokenObject) {\n  return tokenObject?.document?.actor ?? null;\n}\n\nfunction asTokenObject(tokenLike) {\n  return tokenLike?.object ?? tokenLike ?? null;\n}\n\nfunction forEachSceneToken(callback) {\n  for (const token of canvas.tokens.placeables) callback(token);\n}\n\nfunction forEachActorToken(actor, callback) {\n  if (!actor) return;\n  for (const token of actor.getActiveTokens(true)) {\n    const tokenObject = asTokenObject(token);\n    if (tokenObject) callback(tokenObject);\n  }\n}\n\nfunction getActorTokenObjects(actor) {\n  const seen = new Set();\n  const tokens = [];\n  forEachActorToken(actor, (tokenObject) => {\n    if (!tokenObject?.id || seen.has(tokenObject.id)) return;\n    seen.add(tokenObject.id);\n    tokens.push(tokenObject);\n  });\n\n  const syntheticToken = asTokenObject(actor?.token);\n  if (syntheticToken?.id && !seen.has(syntheticToken.id)) {\n    seen.add(syntheticToken.id);\n    tokens.push(syntheticToken);\n  }\n\n  return tokens;\n}\n\nfunction preventPointerDefault(event) {\n  event.stopPropagation();\n  event.nativeEvent?.preventDefault?.();\n}\n\nfunction getMouseButton(event) {\n  return event.button ?? event.data?.button ?? event.nativeEvent?.button ?? 0;\n}\n\nfunction isShiftModifier(event) {\n  if (event?.shiftKey === true) return true;\n  if (event?.data?.originalEvent?.shiftKey === true) return true;\n  if (event?.nativeEvent?.shiftKey === true) return true;\n  return game.keyboard?.isModifierActive?.(KeyboardManager.MODIFIER_KEYS.SHIFT) === true;\n}\n\nfunction getWorldPoint(event) {\n  const global = event?.global ?? event?.data?.global;\n  if (global && canvas?.stage?.worldTransform) {\n    return canvas.stage.worldTransform.applyInverse(global);\n  }\n  return canvas.mousePosition ?? null;\n}\n\nfunction getScreenPoint(event) {\n  return event?.global ?? event?.data?.global ?? null;\n}\n\nfunction getTooltipPointFromEvent(event) {\n  return getScreenPoint(event) ?? getWorldPoint(event);\n}\n\nfunction bindTooltipHandlers(displayObject, getTooltipData, keyStore = null) {\n  if (!displayObject || typeof getTooltipData !== \"function\") return null;\n\n  const onShow = (event) => {\n    const point = getTooltipPointFromEvent(event);\n    if (!point) return;\n    const data = getTooltipData(event) ?? {};\n    const title = data.title ?? data.name ?? \"\";\n    const description = data.description ?? \"No description.\";\n    if (!title) return;\n    showOverlayTooltip(title, description, point);\n  };\n  const onHide = () => hideStatusTooltip();\n\n  displayObject.on(\"pointerover\", onShow);\n  displayObject.on(\"pointermove\", onShow);\n  displayObject.on(\"pointerout\", onHide);\n  displayObject.on(\"pointerupoutside\", onHide);\n  displayObject.on(\"pointercancel\", onHide);\n\n  if (keyStore?.over) displayObject[keyStore.over] = onShow;\n  if (keyStore?.move) displayObject[keyStore.move] = onShow;\n  if (keyStore?.out) displayObject[keyStore.out] = onHide;\n  return { onShow, onHide };\n}\n\nfunction tokenAtPoint(point, { excludeTokenId } = {}) {\n  if (!point) return null;\n  const placeables = [...canvas.tokens.placeables];\n  for (let i = placeables.length - 1; i >= 0; i--) {\n    const token = placeables[i];\n    if (!token || token.destroyed || !token.visible) continue;\n    if (token.id === excludeTokenId) continue;\n    if (point.x >= token.x && point.x <= token.x + token.w && point.y >= token.y && point.y <= token.y + token.h) {\n      return token;\n    }\n  }\n  return null;\n}\n\nfunction setSingleTarget(token) {\n  if (!token) return;\n  const currentTargets = Array.from(game.user.targets ?? []);\n  if (currentTargets.length === 1 && currentTargets[0]?.id === token.id) return;\n\n  const state = game[MODULE_KEY];\n  if (state) {\n    if (!state.recentTargets) state.recentTargets = new Map();\n    const key = `${game.user.id}:${token.id}`;\n    const now = Date.now();\n    const last = Number(state.recentTargets.get(key) ?? 0);\n    if (now - last < TARGET_DEDUPE_WINDOW_MS) return;\n    state.recentTargets.set(key, now);\n  }\n\n  if (typeof game.user.updateTokenTargets === \"function\") {\n    game.user.updateTokenTargets([token.id]);\n    return;\n  }\n\n  token.setTarget(true, { releaseOthers: true, groupSelection: false });\n}\n\nfunction shouldRunDragAttack(sourceToken, targetToken) {\n  const state = game[MODULE_KEY];\n  if (!state) return true;\n\n  if (!state.recentAttacks) state.recentAttacks = new Map();\n  const key = `${game.user.id}:${sourceToken?.id ?? \"none\"}:${targetToken?.id ?? \"none\"}`;\n  const now = Date.now();\n  const last = Number(state.recentAttacks.get(key) ?? 0);\n  if (now - last < ATTACK_DEDUPE_WINDOW_MS) return false;\n\n  state.recentAttacks.set(key, now);\n  if (state.recentAttacks.size > 100) {\n    for (const [mapKey, ts] of state.recentAttacks.entries()) {\n      if (now - Number(ts) > ATTACK_DEDUPE_WINDOW_MS * 3) state.recentAttacks.delete(mapKey);\n    }\n  }\n  return true;\n}\n\nfunction createDragLine() {\n  const line = new PIXI.Graphics();\n  line.eventMode = \"none\";\n  canvas.tokens.addChild(line);\n  return line;\n}\n\nfunction drawDragLine(line, fromPoint, toPoint) {\n  if (!line || !fromPoint || !toPoint) return;\n\n  const dx = toPoint.x - fromPoint.x;\n  const dy = toPoint.y - fromPoint.y;\n  const angle = Math.atan2(dy, dx);\n  const leftAngle = angle + (Math.PI * 5 / 6);\n  const rightAngle = angle - (Math.PI * 5 / 6);\n  const leftX = toPoint.x + (Math.cos(leftAngle) * DRAG_ARROW_SIZE);\n  const leftY = toPoint.y + (Math.sin(leftAngle) * DRAG_ARROW_SIZE);\n  const rightX = toPoint.x + (Math.cos(rightAngle) * DRAG_ARROW_SIZE);\n  const rightY = toPoint.y + (Math.sin(rightAngle) * DRAG_ARROW_SIZE);\n\n  line.clear();\n  line.lineStyle({\n    width: DRAG_LINE_OUTER_WIDTH,\n    color: DRAG_LINE_OUTER_COLOR,\n    alpha: DRAG_LINE_OUTER_ALPHA,\n    cap: \"round\",\n    join: \"round\"\n  });\n  line.moveTo(fromPoint.x, fromPoint.y);\n  line.lineTo(toPoint.x, toPoint.y);\n  line.moveTo(toPoint.x, toPoint.y);\n  line.lineTo(leftX, leftY);\n  line.moveTo(toPoint.x, toPoint.y);\n  line.lineTo(rightX, rightY);\n\n  line.lineStyle({\n    width: DRAG_LINE_INNER_WIDTH,\n    color: DRAG_LINE_INNER_COLOR,\n    alpha: DRAG_LINE_INNER_ALPHA,\n    cap: \"round\",\n    join: \"round\"\n  });\n  line.moveTo(fromPoint.x, fromPoint.y);\n  line.lineTo(toPoint.x, toPoint.y);\n  line.moveTo(toPoint.x, toPoint.y);\n  line.lineTo(leftX, leftY);\n  line.moveTo(toPoint.x, toPoint.y);\n  line.lineTo(rightX, rightY);\n\n  line.lineStyle({\n    width: DRAG_ENDPOINT_RING_WIDTH + 1,\n    color: DRAG_LINE_OUTER_COLOR,\n    alpha: DRAG_LINE_OUTER_ALPHA\n  });\n  line.beginFill(DRAG_LINE_INNER_COLOR, DRAG_LINE_INNER_ALPHA);\n  line.drawCircle(fromPoint.x, fromPoint.y, DRAG_ENDPOINT_OUTER_RADIUS);\n  line.endFill();\n}\n\nfunction clearDragLine(line) {\n  if (!line) return;\n  line.parent?.removeChild(line);\n  line.destroy();\n}\n\nasync function executeFirstMacroByNameCandidates(candidates) {\n  const macro = candidates\n    .map((name) => game.macros.getName(name))\n    .find(Boolean);\n  if (!macro) return false;\n  await macro.execute();\n  return true;\n}\n\nasync function ensureTowActionsRuntime() {\n  for (const macroName of ACTIONS_RUNTIME_PARTS) {\n    const macro = game.macros.getName(macroName);\n    if (!macro) return false;\n    await macro.execute();\n  }\n  return executeFirstMacroByNameCandidates(ACTIONS_RUNTIME_LOADER_CANDIDATES);\n}\n\nasync function ensureTowActions() {\n  const hasApi = typeof game.towActions?.attackActor === \"function\" &&\n    typeof game.towActions?.defenceActor === \"function\" &&\n    typeof game.towActions?.isShiftHeld === \"function\";\n  if (hasApi) return true;\n\n  try {\n    await ensureTowActionsRuntime();\n  } catch (error) {\n    console.error(\"[overlay-toggle] Failed to execute actions runtime macros.\", error);\n  }\n\n  let loaded = typeof game.towActions?.attackActor === \"function\" &&\n    typeof game.towActions?.defenceActor === \"function\" &&\n    typeof game.towActions?.isShiftHeld === \"function\";\n  if (loaded) return true;\n\n  try {\n    const legacyLoaded = await executeFirstMacroByNameCandidates(LIB_MACRO_CANDIDATES);\n    if (!legacyLoaded) {\n      const attempted = [...ACTIONS_RUNTIME_PARTS, ...ACTIONS_RUNTIME_LOADER_CANDIDATES, ...LIB_MACRO_CANDIDATES];\n      ui.notifications.error(`Shared actions macro not found. Tried: ${attempted.join(\", \")}`);\n      return false;\n    }\n  } catch (error) {\n    console.error(\"[overlay-toggle] Failed to execute shared actions macro.\", error);\n    ui.notifications.error(\"Failed to load shared actions macro.\");\n    return false;\n  }\n\n  loaded = typeof game.towActions?.attackActor === \"function\" &&\n    typeof game.towActions?.defenceActor === \"function\" &&\n    typeof game.towActions?.isShiftHeld === \"function\";\n  if (!loaded) {\n    ui.notifications.error(\"Shared actions loaded, but ATK/DEF API is unavailable.\");\n  }\n  return loaded;\n}\n\nfunction armDefaultStaggerChoiceWound(durationMs = AUTO_STAGGER_PATCH_MS) {\n  const state = game[MODULE_KEY];\n  const DialogApi = foundry.applications?.api?.Dialog;\n  if (!state || typeof DialogApi?.wait !== \"function\") return () => {};\n\n  if (!state.staggerWaitPatch) {\n    const originalWait = DialogApi.wait.bind(DialogApi);\n    state.staggerWaitPatch = { originalWait, refs: 0 };\n\n    DialogApi.wait = async (config, options) => {\n      const title = String(config?.window?.title ?? \"\");\n      const content = String(config?.content ?? \"\");\n      const actions = Array.isArray(config?.buttons)\n        ? config.buttons.map((b) => String(b?.action ?? \"\"))\n        : Object.values(config?.buttons ?? {}).map((b) => String(b?.action ?? \"\"));\n      const hasStaggerChoices = actions.includes(\"wound\")\n        && (actions.includes(\"prone\") || actions.includes(\"give\"));\n      const likelyStaggerText = title.toLowerCase().includes(\"stagger\")\n        || content.toLowerCase().includes(\"stagger\")\n        || content.toLowerCase().includes(\"choose from the following options\");\n      if (hasStaggerChoices || likelyStaggerText) return \"wound\";\n      return state.staggerWaitPatch.originalWait(config, options);\n    };\n  }\n\n  state.staggerWaitPatch.refs += 1;\n  let restored = false;\n  const restore = () => {\n    if (restored) return;\n    restored = true;\n    if (!state.staggerWaitPatch) return;\n    state.staggerWaitPatch.refs = Math.max(0, state.staggerWaitPatch.refs - 1);\n    if (state.staggerWaitPatch.refs === 0) {\n      DialogApi.wait = state.staggerWaitPatch.originalWait;\n      delete state.staggerWaitPatch;\n    }\n  };\n\n  const timer = setTimeout(restore, durationMs);\n  return () => {\n    clearTimeout(timer);\n    restore();\n  };\n}\n\nfunction armAutoDefenceForOpposed(sourceToken, targetToken, { sourceBeforeState } = {}) {\n  if (!sourceToken?.actor || !targetToken?.actor?.isOwner) return;\n\n  let timeoutId = null;\n  const cleanup = (hookId) => {\n    Hooks.off(\"createChatMessage\", hookId);\n    if (timeoutId) clearTimeout(timeoutId);\n    timeoutId = null;\n  };\n\n  const hookId = Hooks.on(\"createChatMessage\", async (message) => {\n    if (message?.type !== \"opposed\") return;\n    if (message.system?.defender?.token !== targetToken.id) return;\n\n    const attackerMessage = game.messages.get(message.system?.attackerMessage);\n    const attackerActorUuid = attackerMessage?.system?.test?.actor;\n    if (attackerActorUuid && attackerActorUuid !== sourceToken.actor.uuid) return;\n\n    const state = game[MODULE_KEY];\n    if (state) {\n      if (!state.autoDefenceHandled) state.autoDefenceHandled = new Set();\n      if (state.autoDefenceHandled.has(message.id)) return;\n      state.autoDefenceHandled.add(message.id);\n    }\n\n    cleanup(hookId);\n    if (!(await ensureTowActions())) return;\n\n    const started = Date.now();\n    while (Date.now() - started < OPPOSED_LINK_WAIT_MS) {\n      if (targetToken.actor.system?.opposed?.id === message.id) break;\n      await new Promise((resolve) => setTimeout(resolve, 50));\n    }\n\n    await game.towActions.defenceActor(targetToken.actor, { manual: false });\n    armAutoApplyDamageForOpposed(message, {\n      sourceActor: sourceToken.actor,\n      sourceBeforeState\n    });\n  });\n\n  timeoutId = setTimeout(() => cleanup(hookId), AUTO_DEFENCE_WAIT_MS);\n}\n\nfunction armAutoApplyDamageForOpposed(opposedMessage, { sourceActor = null, sourceBeforeState = null } = {}) {\n  if (!opposedMessage?.id) return;\n  const state = game[MODULE_KEY];\n  if (state) {\n    if (!state.autoApplyArmed) state.autoApplyArmed = new Set();\n    if (state.autoApplyArmed.has(opposedMessage.id)) return;\n    state.autoApplyArmed.add(opposedMessage.id);\n  }\n\n  const cleanup = () => {\n    state?.autoApplyArmed?.delete(opposedMessage.id);\n    state?.autoDefenceHandled?.delete(opposedMessage.id);\n  };\n  void (async () => {\n    let applying = false;\n    let separatorPosted = false;\n    const postSeparatorOnce = async (opposed) => {\n      if (separatorPosted) return;\n      separatorPosted = true;\n      const sourceStatusHints = await deriveSourceStatusHints(sourceActor, sourceBeforeState);\n      await postFlowSeparatorCard(opposed, { sourceStatusHints, targetStatusHints: [] });\n    };\n\n    const started = Date.now();\n    while (Date.now() - started < AUTO_APPLY_WAIT_MS) {\n      const message = game.messages.get(opposedMessage.id);\n      const opposed = message?.system;\n      if (!opposed) {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        continue;\n      }\n\n      const computed = opposed.result?.computed === true;\n      const hasDamage = typeof opposed.result?.damage !== \"undefined\" && opposed.result?.damage !== null;\n      const alreadyApplied = opposed.result?.damage?.applied === true;\n      if (!computed) {\n        await new Promise((resolve) => setTimeout(resolve, 100));\n        continue;\n      }\n\n      if (!hasDamage || alreadyApplied) {\n        await postSeparatorOnce(opposed);\n        break;\n      }\n\n      const defenderActor = ChatMessage.getSpeakerActor(opposed.defender);\n      if (!defenderActor?.isOwner || applying) {\n        await postSeparatorOnce(opposed);\n        break;\n      }\n\n      applying = true;\n      const beforeState = snapshotActorState(defenderActor);\n      const damageValue = Number(opposed.result?.damage?.value ?? 0);\n      await applyDamageWithWoundsFallback(defenderActor, damageValue, {\n        opposed,\n        item: opposed.attackerTest?.item,\n        test: opposed.attackerMessage?.system?.test\n      });\n      const afterState = await captureSettledActorState(defenderActor, beforeState, 700);\n      const targetStatusHints = deriveAppliedStatusLabels(beforeState, afterState);\n      const sourceStatusHints = await deriveSourceStatusHints(sourceActor, sourceBeforeState);\n      if (!separatorPosted) {\n        separatorPosted = true;\n        await postFlowSeparatorCard(opposed, { sourceStatusHints, targetStatusHints });\n      }\n      break;\n    }\n    cleanup();\n  })();\n}\n\nasync function applyDamageWithWoundsFallback(defenderActor, damageValue, context) {\n  const system = defenderActor?.system;\n  if (!system || typeof system.applyDamage !== \"function\") return;\n\n  const originalAddWound = (typeof system.addWound === \"function\") ? system.addWound.bind(system) : null;\n  if (!originalAddWound) {\n    await system.applyDamage(damageValue, context);\n    return;\n  }\n\n  system.addWound = async function wrappedAddWound(options = {}) {\n    const tableId = game.settings.get(\"whtow\", \"tableSettings\")?.wounds;\n    const hasTable = !!(tableId && game.tables.get(tableId));\n\n    if (!hasTable) {\n      // Keep system wound/death scripts; only bypass table rolling.\n      return originalAddWound({ ...options, roll: false });\n    }\n    try {\n      return await originalAddWound(options);\n    } catch (error) {\n      const message = String(error?.message ?? error ?? \"\");\n      if (message.includes(\"No table found for wounds\")) {\n        return originalAddWound({ ...options, roll: false });\n      }\n      throw error;\n    }\n  };\n\n  try {\n    await system.applyDamage(damageValue, context);\n  } finally {\n    system.addWound = originalAddWound;\n  }\n}\n\nfunction snapshotActorState(actor) {\n  const statuses = new Set(Array.from(actor?.statuses ?? []).map((s) => String(s)));\n  for (const effect of Array.from(actor?.effects?.contents ?? [])) {\n    for (const status of Array.from(effect?.statuses ?? [])) {\n      statuses.add(String(status));\n    }\n  }\n  const wounds = Number(actor?.itemTypes?.wound?.length ?? 0);\n  return { statuses, wounds };\n}\n\nasync function captureSettledActorState(actor, baselineState, settleMs = 700) {\n  const started = Date.now();\n  let last = snapshotActorState(actor);\n  let stableFor = 0;\n\n  while (Date.now() - started < settleMs) {\n    await new Promise((resolve) => setTimeout(resolve, 80));\n    const current = snapshotActorState(actor);\n    const sameWounds = current.wounds === last.wounds;\n    const sameStatuses = current.statuses.size === last.statuses.size\n      && Array.from(current.statuses).every((s) => last.statuses.has(s));\n    if (sameWounds && sameStatuses) {\n      stableFor += 80;\n      if (stableFor >= 160) return current;\n    } else {\n      stableFor = 0;\n      last = current;\n    }\n  }\n\n  const finalState = snapshotActorState(actor);\n  if ((finalState.wounds ?? 0) < (baselineState?.wounds ?? 0)) return last;\n  return finalState;\n}\n\nasync function deriveSourceStatusHints(sourceActor, sourceBeforeState) {\n  if (!sourceActor || !sourceBeforeState) return [];\n  const sourceAfterState = await captureSettledActorState(sourceActor, sourceBeforeState, 500);\n  return deriveAppliedStatusLabels(sourceBeforeState, sourceAfterState);\n}\n\nfunction deriveAppliedStatusLabels(before, after) {\n  const labels = [];\n  const add = (label) => {\n    if (!label) return;\n    if (!labels.includes(label)) labels.push(label);\n  };\n\n  if ((after?.wounds ?? 0) > (before?.wounds ?? 0)) add(\"Wound\");\n\n  const beforeStatuses = before?.statuses ?? new Set();\n  const afterStatuses = after?.statuses ?? new Set();\n  for (const statusId of afterStatuses) {\n    if (beforeStatuses.has(statusId)) continue;\n    const label = game.oldworld?.config?.conditions?.[statusId]?.name\n      ?? game.i18n.localize(`TOW.ConditionName.${statusId}`)\n      ?? statusId;\n    add(label);\n  }\n  return labels;\n}\n\nfunction getFlowNamesMarkup(attackerName, defenderName) {\n  const attackerSafe = foundry.utils.escapeHTML(attackerName);\n  const defenderSafe = foundry.utils.escapeHTML(defenderName);\n  const combinedLen = `${attackerName} vs. ${defenderName}`.length;\n  const needsStacked = combinedLen > 34 || attackerName.length > 18 || defenderName.length > 18;\n\n  if (!needsStacked) {\n    return `<div style=\"font-size: inherit; text-align:center; font-weight:700;\">\n      ${attackerSafe} vs. ${defenderSafe}\n    </div>`;\n  }\n\n  return `<div style=\"font-size: inherit; text-align:center; font-weight:700; display:flex; flex-direction:column; align-items:center; line-height:1.2; gap:1px;\">\n    <div>${attackerSafe}</div>\n    <div style=\"font-weight:600; opacity:0.85;\">vs.</div>\n    <div>${defenderSafe}</div>\n  </div>`;\n}\n\nasync function postFlowSeparatorCard(opposed, { sourceStatusHints = [], targetStatusHints = [] } = {}) {\n  const attackerName = opposed?.attackerToken?.name ?? \"Attacker\";\n  const defenderName = opposed?.defenderToken?.name ?? opposed?.defender?.alias ?? \"Defender\";\n  const outcome = opposed?.result?.outcome ?? \"resolved\";\n  const outcomeText = String(outcome);\n  const outcomeLabel = outcomeText.charAt(0).toUpperCase() + outcomeText.slice(1).toLowerCase();\n  const margin = Number(opposed?.result?.successes ?? 0);\n  const marginLabel = `${margin >= 0 ? \"+\" : \"\"}${margin}`;\n  const damageValue = Number(opposed?.result?.damage?.value ?? 0);\n  const damageLabel = Number.isFinite(damageValue) && damageValue > 0 ? String(damageValue) : \"0\";\n\n  const statusLabels = [];\n  const pushStatus = (label) => {\n    if (!label) return;\n    if (!statusLabels.includes(label)) statusLabels.push(label);\n  };\n\n  const damageMessageKey = String(opposed?.result?.damage?.message ?? \"\");\n  if (damageMessageKey.includes(\"TakesWound\")) pushStatus(\"Wound\");\n  if (damageMessageKey.includes(\"GainsStaggered\")) pushStatus(\"Staggered\");\n  if (damageMessageKey.includes(\"SuffersFault\")) pushStatus(\"Fault\");\n\n  const effectStatuses = Array.isArray(opposed?.attackerTest?.damageEffects)\n    ? opposed.attackerTest.damageEffects.flatMap((effect) => Array.from(effect?.statuses ?? []))\n    : [];\n  for (const status of effectStatuses) {\n    const key = String(status ?? \"\");\n    const label = game.oldworld?.config?.conditions?.[key]?.name\n      ?? game.i18n.localize(`TOW.ConditionName.${key}`)\n      ?? key;\n    pushStatus(label);\n  }\n\n  for (const label of targetStatusHints) pushStatus(label);\n  const targetStatusLabels = [...statusLabels];\n  const sourceStatusLabels = Array.from(new Set((sourceStatusHints ?? []).filter(Boolean)));\n\n  const outcomeColor = outcome === \"success\"\n    ? \"#2e7d32\"\n    : outcome === \"failure\"\n      ? \"#9b1c1c\"\n      : \"#6b5e3a\";\n  const marginColor = margin > 0 ? \"#2e7d32\" : margin < 0 ? \"#9b1c1c\" : \"#6b5e3a\";\n  const damageColor = damageValue > 0 ? \"#9b1c1c\" : \"#6b5e3a\";\n\n  const statusColorFor = (label) => {\n    const key = String(label).toLowerCase();\n    if (key.includes(\"wound\")) return { bg: \"#5e1f1f\", fg: \"#ffd9d9\", border: \"#b75b5b\" };\n    if (key.includes(\"stagger\")) return { bg: \"#5a4a18\", fg: \"#ffe8a6\", border: \"#c9a447\" };\n    if (key.includes(\"prone\")) return { bg: \"#24344f\", fg: \"#d6e6ff\", border: \"#5f84c6\" };\n    if (key.includes(\"fault\")) return { bg: \"#4b214f\", fg: \"#f0d8ff\", border: \"#a164bf\" };\n    return { bg: \"#3a362b\", fg: \"#efe8d2\", border: \"#8f8468\" };\n  };\n\n  const statusMarkupFrom = (labels) => labels.length\n    ? labels.map((label) => {\n      const c = statusColorFor(label);\n      return `<span style=\"\n        display:inline-block;\n        margin:0 2px;\n        padding:1px 6px;\n        border-radius:10px;\n        border:1px solid ${c.border};\n        background:${c.bg};\n        color:${c.fg};\n        font-size:${FLOW_CARD_CHIP_FONT_SIZE};\n        line-height:1.4;\n      \">${foundry.utils.escapeHTML(label)}</span>`;\n    }).join(\"\")\n    : `<span style=\"\n      display:inline-block;\n      margin:0 2px;\n      padding:1px 6px;\n      border-radius:10px;\n      border:1px solid #8f8468;\n      background:#3a362b;\n      color:#efe8d2;\n      font-size:${FLOW_CARD_CHIP_FONT_SIZE};\n      line-height:1.4;\n    \">None</span>`;\n  const sourceStatusMarkup = statusMarkupFrom(sourceStatusLabels);\n  const targetStatusMarkup = statusMarkupFrom(targetStatusLabels);\n  const namesMarkup = getFlowNamesMarkup(attackerName, defenderName);\n\n  const content = `<div style=\"\n      border-top: 1px solid rgba(130,110,80,0.45);\n      border-bottom: 1px solid rgba(130,110,80,0.45);\n      margin: 4px 0;\n      padding: 7px 8px;\n      text-align: center;\n      letter-spacing: 0.04em;\n      opacity: 0.9;\n      line-height: 1.35;\n      font-size: ${FLOW_CARD_FONT_SIZE};\">\n      ${namesMarkup}\n      <div style=\"margin-top:2px; font-size: inherit; text-align:center;\">\n        <strong style=\"color:${outcomeColor};\">${foundry.utils.escapeHTML(outcomeLabel)}</strong>\n      </div>\n      <div style=\"margin-top:2px; font-size: inherit; text-align:center;\">\n        Margin: <strong style=\"color:${marginColor};\">${foundry.utils.escapeHTML(marginLabel)}</strong>\n        &nbsp;|&nbsp;\n        Damage: <strong style=\"color:${damageColor};\">${foundry.utils.escapeHTML(damageLabel)}</strong>\n      </div>\n      <div style=\"margin-top:5px; display:flex; flex-direction:column; gap:4px; align-items:stretch; text-align:left;\">\n        <div style=\"display:flex; gap:6px; align-items:center; flex-wrap:wrap;\">\n          <span style=\"opacity:0.8; min-width:56px;\">Source:</span>\n          <div style=\"display:flex; gap:4px; flex-wrap:wrap;\">${sourceStatusMarkup}</div>\n        </div>\n        <div style=\"display:flex; gap:6px; align-items:center; flex-wrap:wrap;\">\n          <span style=\"opacity:0.8; min-width:56px;\">Target:</span>\n          <div style=\"display:flex; gap:4px; flex-wrap:wrap;\">${targetStatusMarkup}</div>\n        </div>\n      </div>\n    </div>`;\n\n  await ChatMessage.create({\n    content,\n    speaker: { alias: \"Combat Flow\" }\n  });\n}\n");
})();
