// Auto-generated by macros/tools/build-overlay-runtime-libs.mjs
// Registers overlay runtime source part: 20-controls
(() => {
  const bundle = game["towOverlayRuntimeBundleV1"] ?? (game["towOverlayRuntimeBundleV1"] = {
    version: "1.0.0",
    parts: new Map(),
    order: ["00-header-and-combat","10-layout-and-state","20-controls","30-status-and-api"]
  });
  bundle.version = "1.0.0";
  if (!(bundle.parts instanceof Map)) bundle.parts = new Map();
  bundle.parts.set("20-controls", "function getControlStyle() {\n  const style = CONFIG.canvasTextStyle?.clone?.() ?? new PIXI.TextStyle();\n  style.fontFamily = \"CaslonPro\";\n  style.fontWeight = \"700\";\n  style.fontSize = OVERLAY_FONT_SIZE;\n  style.fill = \"#FFF4D8\";\n  style.stroke = \"rgba(5, 5, 5, 0.76)\";\n  style.strokeThickness = 2;\n  style.lineJoin = \"round\";\n  style.miterLimit = 2;\n  style.dropShadow = false;\n  style.align = \"left\";\n  return style;\n}\n\nfunction getNameStyle() {\n  const style = getControlStyle();\n  style.align = \"center\";\n  return style;\n}\n\nfunction getNameTypeStyle() {\n  const style = getControlStyle();\n  style.align = \"center\";\n  return style;\n}\n\nfunction getIconValueStyle() {\n  const style = getControlStyle();\n  style.fontWeight = \"700\";\n  return style;\n}\n\nfunction createOverlayIconSprite(src, size = OVERLAY_FONT_SIZE + 2) {\n  const OutlineFilterClass = PIXI?.filters?.OutlineFilter ?? PIXI?.OutlineFilter;\n  if (typeof OutlineFilterClass === \"function\") {\n    const sprite = PIXI.Sprite.from(src);\n    sprite.width = size;\n    sprite.height = size;\n    sprite.tint = OVERLAY_CONTROL_ICON_TINT;\n    sprite.alpha = 0.98;\n    const outline = new OutlineFilterClass(\n      OVERLAY_CONTROL_ICON_OUTLINE_THICKNESS,\n      OVERLAY_CONTROL_ICON_OUTLINE_COLOR,\n      1\n    );\n    if (\"alpha\" in outline) outline.alpha = OVERLAY_CONTROL_ICON_OUTLINE_ALPHA;\n    sprite.filters = [outline];\n    sprite.eventMode = \"none\";\n    return sprite;\n  }\n\n  // Runtime-safe fallback when OutlineFilter is unavailable: fake stroke with offset clones.\n  const container = new PIXI.Container();\n  container.eventMode = \"none\";\n  const offsets = [\n    [-1, -1], [0, -1], [1, -1],\n    [-1, 0],            [1, 0],\n    [-1, 1],  [0, 1],  [1, 1]\n  ];\n  for (const [dx, dy] of offsets) {\n    const strokeSprite = PIXI.Sprite.from(src);\n    strokeSprite.width = size;\n    strokeSprite.height = size;\n    strokeSprite.tint = OVERLAY_CONTROL_ICON_OUTLINE_COLOR;\n    strokeSprite.alpha = OVERLAY_CONTROL_ICON_OUTLINE_ALPHA;\n    strokeSprite.position.set(dx, dy);\n    strokeSprite.eventMode = \"none\";\n    container.addChild(strokeSprite);\n  }\n\n  const sprite = PIXI.Sprite.from(src);\n  sprite.width = size;\n  sprite.height = size;\n  sprite.tint = OVERLAY_CONTROL_ICON_TINT;\n  sprite.alpha = 0.98;\n  sprite.eventMode = \"none\";\n  container.addChild(sprite);\n  return container;\n}\n\nfunction getActorTypeLabel(actor) {\n  const systemType = String(actor?.system?.type ?? \"\").trim();\n  if (systemType) return systemType;\n  const actorType = String(actor?.type ?? \"\").trim();\n  if (actorType) return actorType;\n  return \"actor\";\n}\n\nfunction tuneOverlayText(textObject) {\n  if (!textObject) return;\n  textObject.roundPixels = true;\n  const devicePixelRatio = Math.max(1, Number(window.devicePixelRatio ?? 1));\n  const canvasScale = Number(canvas?.stage?.scale?.x ?? 1);\n  const zoom = (Number.isFinite(canvasScale) && canvasScale > 0) ? canvasScale : 1;\n  const zoomBoost = zoom < 1 ? (1 / zoom) : 1;\n  const resolution = Math.min(\n    OVERLAY_TEXT_RESOLUTION_MAX,\n    Math.max(OVERLAY_TEXT_RESOLUTION_MIN, Math.ceil(devicePixelRatio * zoomBoost))\n  );\n  if (\"resolution\" in textObject && textObject.resolution !== resolution) {\n    textObject.resolution = resolution;\n    textObject.dirty = true;\n  }\n}\n\nfunction drawHitBoxRect(graphics, x, y, width, height) {\n  graphics.clear();\n  graphics.beginFill(0x000000, 0.001);\n  graphics.drawRoundedRect(x, y, width, height, 6);\n  graphics.endFill();\n}\n\nfunction createWoundControlUI(tokenObject) {\n  for (const child of canvas.tokens.children ?? []) {\n    if (child?.[KEYS.woundUiMarker] === true && child?.[KEYS.woundUiTokenId] === tokenObject.id) {\n      clearDisplayObject(child);\n    }\n  }\n\n  const container = new PIXI.Container();\n  container.eventMode = \"passive\";\n  container.interactiveChildren = true;\n  container[KEYS.woundUiMarker] = true;\n  container[KEYS.woundUiTokenId] = tokenObject.id;\n\n  const countText = new PreciseTextClass(\"\", getIconValueStyle());\n  tuneOverlayText(countText);\n  countText.anchor.set(0, 0.5);\n  countText.eventMode = \"none\";\n  const countIcon = createOverlayIconSprite(ICON_SRC_WOUND, OVERLAY_FONT_SIZE + 1);\n\n  const countHitBox = new PIXI.Graphics();\n  countHitBox.eventMode = \"static\";\n  countHitBox.interactive = true;\n  countHitBox.buttonMode = true;\n  countHitBox.cursor = \"pointer\";\n\n  const attackIcon = createOverlayIconSprite(ICON_SRC_ATK, OVERLAY_FONT_SIZE + 2);\n\n  const defenceIcon = createOverlayIconSprite(ICON_SRC_DEF, OVERLAY_FONT_SIZE + 2);\n\n  const attackHitBox = new PIXI.Graphics();\n  attackHitBox.eventMode = \"static\";\n  attackHitBox.interactive = true;\n  attackHitBox.buttonMode = true;\n  attackHitBox.cursor = \"grab\";\n\n  const defenceHitBox = new PIXI.Graphics();\n  defenceHitBox.eventMode = \"static\";\n  defenceHitBox.interactive = true;\n  defenceHitBox.buttonMode = true;\n  defenceHitBox.cursor = \"pointer\";\n\n  countHitBox.on(\"pointerdown\", async (event) => {\n    preventPointerDefault(event);\n    const actor = getActorFromToken(tokenObject);\n    if (!actor) return;\n\n    if (getMouseButton(event) !== 0) {\n      return;\n    }\n    await addWound(actor);\n  });\n  countHitBox.on(\"rightdown\", async (event) => {\n    preventPointerDefault(event);\n    const actor = getActorFromToken(tokenObject);\n    if (!actor) return;\n    await removeWound(actor);\n  });\n  countHitBox.on(\"contextmenu\", preventPointerDefault);\n  bindTooltipHandlers(countHitBox, () => ({\n    title: \"Wounds\",\n    description: \"Left-click adds 1 wound. Right-click removes 1 wound.\"\n  }));\n\n  attackHitBox.on(\"pointerdown\", async (event) => {\n    preventPointerDefault(event);\n    if (getMouseButton(event) !== 0) return;\n\n    const sourceToken = tokenObject;\n    const sourceActor = getActorFromToken(sourceToken);\n    if (!sourceActor) return;\n    if (!(await ensureTowActions())) return;\n\n    const pointerDownShift = isShiftModifier(event);\n    const origin = {\n      x: sourceToken.x + (sourceToken.w / 2),\n      y: sourceToken.y + (sourceToken.h / 2)\n    };\n    const startScreenPoint = getScreenPoint(event) ?? getWorldPoint(event) ?? origin;\n    let dragStarted = false;\n    let dragFinished = false;\n    let dragLine = null;\n    attackHitBox.cursor = \"grabbing\";\n\n    const cleanupDrag = () => {\n      canvas.stage.off(\"pointermove\", onDragMove);\n      canvas.stage.off(\"pointerup\", finishDrag);\n      canvas.stage.off(\"pointerupoutside\", finishDrag);\n      clearDragLine(dragLine);\n      dragLine = null;\n      attackHitBox.cursor = \"grab\";\n    };\n\n    const onDragMove = (moveEvent) => {\n      const point = getWorldPoint(moveEvent);\n      if (!point) return;\n      const screenPoint = getScreenPoint(moveEvent) ?? point;\n      const dx = screenPoint.x - startScreenPoint.x;\n      const dy = screenPoint.y - startScreenPoint.y;\n      if (!dragStarted) {\n        if (Math.hypot(dx, dy) < DRAG_START_THRESHOLD_PX) return;\n        dragStarted = true;\n        dragLine = createDragLine();\n      }\n      drawDragLine(dragLine, origin, point);\n    };\n\n    const finishDrag = async (upEvent) => {\n      if (dragFinished) return;\n      dragFinished = true;\n      cleanupDrag();\n\n      const shiftManual = pointerDownShift || isShiftModifier(upEvent);\n      if (!dragStarted) {\n        await game.towActions.attackActor(sourceActor, { manual: shiftManual });\n        return;\n      }\n\n      const point = getWorldPoint(upEvent);\n      const target = tokenAtPoint(point, { excludeTokenId: sourceToken.id });\n      if (!target) return;\n      if (!shouldRunDragAttack(sourceToken, target)) return;\n\n      await setSingleTarget(target);\n      const armAutoOpposedFlow = () => {\n        const sourceBeforeState = snapshotActorState(sourceActor);\n        const restoreStaggerPrompt = armDefaultStaggerChoiceWound(AUTO_STAGGER_PATCH_MS);\n        armAutoDefenceForOpposed(sourceToken, target, { sourceBeforeState });\n        return () => setTimeout(() => restoreStaggerPrompt(), AUTO_APPLY_WAIT_MS);\n      };\n      if (shiftManual) {\n        await game.towActions.attackActor(sourceActor, {\n          manual: true,\n          onFastAuto: async () => {\n            armAutoOpposedFlow()();\n          }\n        });\n        return;\n      }\n\n      const restoreAutoFlow = armAutoOpposedFlow();\n      try {\n        await game.towActions.attackActor(sourceActor, { manual: false });\n      } finally {\n        restoreAutoFlow();\n      }\n    };\n\n    canvas.stage.on(\"pointermove\", onDragMove);\n    canvas.stage.on(\"pointerup\", finishDrag);\n    canvas.stage.on(\"pointerupoutside\", finishDrag);\n  });\n  attackHitBox.on(\"contextmenu\", preventPointerDefault);\n  bindTooltipHandlers(attackHitBox, () => ({\n    title: \"Attack\",\n    description: \"Attack roll. Left-click attacks. Drag to a target for quick targeting. Hold Shift for manual mode.\"\n  }));\n\n  defenceHitBox.on(\"pointerdown\", async (event) => {\n    preventPointerDefault(event);\n    if (getMouseButton(event) !== 0) return;\n    const actor = getActorFromToken(tokenObject);\n    if (!actor) return;\n    if (!(await ensureTowActions())) return;\n    await game.towActions.defenceActor(actor, { manual: game.towActions.isShiftHeld() });\n  });\n  defenceHitBox.on(\"contextmenu\", preventPointerDefault);\n  bindTooltipHandlers(defenceHitBox, () => ({\n    title: \"Defence\",\n    description: \"Defence roll. Left-click defends. Hold Shift for manual mode.\"\n  }));\n\n  container.addChild(countHitBox);\n  container.addChild(countIcon);\n  container.addChild(countText);\n  container.addChild(attackHitBox);\n  container.addChild(defenceHitBox);\n  container.addChild(attackIcon);\n  container.addChild(defenceIcon);\n\n  container._countText = countText;\n  container._countIcon = countIcon;\n  container._countHitBox = countHitBox;\n  container._attackHitBox = attackHitBox;\n  container._defenceHitBox = defenceHitBox;\n  container._attackIcon = attackIcon;\n  container._defenceIcon = defenceIcon;\n\n  tokenObject.addChild(container);\n  tokenObject[KEYS.woundUI] = container;\n  return container;\n}\n\nfunction updateWoundControlUI(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n\n  const count = getWoundCount(tokenObject.document);\n  if (count === null || count === undefined) {\n    const ui = tokenObject[KEYS.woundUI];\n    if (!ui) return;\n    clearDisplayObject(ui);\n    delete tokenObject[KEYS.woundUI];\n    return;\n  }\n\n  const existingUi = tokenObject[KEYS.woundUI];\n  const hasBrokenTextStyle = !!existingUi && (\n    !existingUi._countText ||\n    !existingUi._countIcon ||\n    !existingUi._attackIcon ||\n    !existingUi._defenceIcon ||\n    existingUi._countText.destroyed ||\n    existingUi._countIcon.destroyed ||\n    existingUi._attackIcon.destroyed ||\n    existingUi._defenceIcon.destroyed ||\n    !existingUi._countText.style\n  );\n  const staleUi = !!existingUi && (\n    existingUi.destroyed ||\n    existingUi.parent == null ||\n    existingUi.parent !== tokenObject ||\n    hasBrokenTextStyle ||\n    existingUi._attackHitBox?.destroyed ||\n    existingUi._defenceHitBox?.destroyed ||\n    existingUi._countHitBox?.destroyed\n  );\n  if (staleUi) {\n    clearDisplayObject(existingUi);\n    delete tokenObject[KEYS.woundUI];\n  }\n\n  const ui = (!tokenObject[KEYS.woundUI] || tokenObject[KEYS.woundUI].destroyed)\n    ? createWoundControlUI(tokenObject)\n    : tokenObject[KEYS.woundUI];\n  const actor = getActorFromToken(tokenObject);\n\n  const countText = ui._countText;\n  const countIcon = ui._countIcon;\n  const countHitBox = ui._countHitBox;\n  const attackHitBox = ui._attackHitBox;\n  const defenceHitBox = ui._defenceHitBox;\n  const attackIcon = ui._attackIcon;\n  const defenceIcon = ui._defenceIcon;\n  tuneOverlayText(countText);\n\n  try {\n    countText.text = `${count}`;\n  } catch (_error) {\n    clearDisplayObject(ui);\n    delete tokenObject[KEYS.woundUI];\n    return updateWoundControlUI(tokenObject);\n  }\n\n  const padX = 3;\n  const padY = 2;\n  const rowGap = Math.max(18, countText.height + 4);\n  const centerY = 0;\n  const rightBottomY = centerY + (rowGap / 2);\n  const leftTopY = -(rowGap / 2);\n  const leftBottomY = leftTopY + rowGap;\n\n  const countGap = 4;\n  countIcon.position.set(0, Math.round(rightBottomY - (countIcon.height / 2)));\n  countText.position.set(Math.round(countIcon.width + countGap), Math.round(rightBottomY));\n  const countBlockWidth = countIcon.width + countGap + countText.width;\n  const countBlockHeight = Math.max(countIcon.height, countText.height);\n  drawHitBoxRect(\n    countHitBox,\n    -padX,\n    rightBottomY - (countBlockHeight / 2) - padY,\n    countBlockWidth + (padX * 2),\n    countBlockHeight + (padY * 2)\n  );\n\n  ui.position.set(Math.round(tokenObject.w + TOKEN_CONTROL_PAD), Math.round(tokenObject.h / 2));\n\n  const leftX = -(tokenObject.w + (TOKEN_CONTROL_PAD * 2));\n  attackIcon.position.set(\n    Math.round(leftX - attackIcon.width),\n    Math.round(leftTopY - (attackIcon.height / 2))\n  );\n  defenceIcon.position.set(\n    Math.round(leftX - defenceIcon.width),\n    Math.round(leftBottomY - (defenceIcon.height / 2))\n  );\n\n  drawHitBoxRect(\n    attackHitBox,\n    attackIcon.x - padX,\n    attackIcon.y - padY,\n    attackIcon.width + (padX * 2),\n    attackIcon.height + (padY * 2)\n  );\n  drawHitBoxRect(\n    defenceHitBox,\n    defenceIcon.x - padX,\n    defenceIcon.y - padY,\n    defenceIcon.width + (padX * 2),\n    defenceIcon.height + (padY * 2)\n  );\n\n  const editable = canEditActor(actor);\n  countText.alpha = editable ? 1 : 0.45;\n  countIcon.alpha = editable ? 1 : 0.45;\n  attackIcon.alpha = 1;\n  defenceIcon.alpha = 1;\n  ui.visible = tokenObject.visible;\n}\n\nfunction clearAllWoundControls() {\n  forEachSceneToken((token) => {\n    const ui = token[KEYS.woundUI];\n    if (!ui) return;\n    clearDisplayObject(ui);\n    delete token[KEYS.woundUI];\n  });\n\n  const orphaned = [];\n  for (const child of canvas.tokens.children ?? []) {\n    const marked = child?.[KEYS.woundUiMarker] === true;\n    const legacyLikelyWoundUi = child?._countText && child?._attackText && child?._defenceText;\n    if (marked || legacyLikelyWoundUi) orphaned.push(child);\n  }\n  for (const ui of orphaned) clearDisplayObject(ui);\n}\n\nfunction updateNameLabel(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n\n  const tokenName = tokenObject.document?.name ?? tokenObject.name ?? \"\";\n  const actor = tokenObject.document?.actor ?? null;\n  const typeLabel = getActorTypeLabel(actor).toLowerCase();\n  if (!tokenName) {\n    const labelContainer = tokenObject[KEYS.nameLabel];\n    if (!labelContainer) return;\n    labelContainer.parent?.removeChild(labelContainer);\n    labelContainer.destroy({ children: true });\n    delete tokenObject[KEYS.nameLabel];\n    return;\n  }\n\n  let labelContainer = tokenObject[KEYS.nameLabel];\n  if (!labelContainer || labelContainer.destroyed || labelContainer.parent !== tokenObject || !labelContainer._nameText || !labelContainer._typeText) {\n    if (labelContainer && !labelContainer.destroyed) {\n      labelContainer.parent?.removeChild(labelContainer);\n      labelContainer.destroy({ children: true });\n    }\n\n    labelContainer = new PIXI.Container();\n    labelContainer.eventMode = \"static\";\n    labelContainer.interactive = true;\n    labelContainer.cursor = \"help\";\n\n    const nameText = new PreciseTextClass(\"\", getNameStyle());\n    tuneOverlayText(nameText);\n    nameText.anchor.set(0.5, 1);\n    nameText.eventMode = \"none\";\n\n    const typeText = new PreciseTextClass(\"\", getNameTypeStyle());\n    tuneOverlayText(typeText);\n    typeText.anchor.set(0.5, 1);\n    typeText.eventMode = \"none\";\n\n    labelContainer.addChild(nameText);\n    labelContainer.addChild(typeText);\n    labelContainer._nameText = nameText;\n    labelContainer._typeText = typeText;\n    labelContainer[KEYS.nameLabelMarker] = true;\n    labelContainer[KEYS.nameLabelTokenId] = tokenObject.id;\n\n    tokenObject.addChild(labelContainer);\n    tokenObject[KEYS.nameLabel] = labelContainer;\n  }\n\n  const nameText = labelContainer._nameText;\n  const typeText = labelContainer._typeText;\n  tuneOverlayText(nameText);\n  tuneOverlayText(typeText);\n  if (!labelContainer._towTypeTooltipBound) {\n    labelContainer._towTypeTooltipBound = bindTooltipHandlers(labelContainer, () => getTypeTooltipData(actor));\n  }\n  nameText.text = tokenName;\n  typeText.text = `<${typeLabel}>`;\n  const tokenEdgePad = TOKEN_CONTROL_PAD;\n  const lineGap = 0;\n  const typeBounds = typeText.getLocalBounds();\n  const typeBottom = typeBounds.y + typeBounds.height;\n  const typeTop = typeBounds.y;\n  typeText.position.set(0, Math.round(-(tokenEdgePad + typeBottom) + NAME_TYPE_TO_TOKEN_OFFSET_PX));\n\n  const nameBounds = nameText.getLocalBounds();\n  const nameBottom = nameBounds.y + nameBounds.height;\n  nameText.position.set(0, Math.round((typeText.y + typeTop) + NAME_TYPE_STACK_OVERLAP_PX - lineGap - nameBottom));\n  const combinedMinX = Math.min(nameBounds.x, typeBounds.x);\n  const combinedMinY = Math.min(nameText.y + nameBounds.y, typeText.y + typeBounds.y);\n  const combinedMaxX = Math.max(nameBounds.x + nameBounds.width, typeBounds.x + typeBounds.width);\n  const combinedMaxY = Math.max(nameText.y + nameBounds.y + nameBounds.height, typeText.y + typeBounds.y + typeBounds.height);\n  labelContainer.hitArea = new PIXI.Rectangle(\n    Math.floor(combinedMinX - 4),\n    Math.floor(combinedMinY - 2),\n    Math.max(8, Math.ceil((combinedMaxX - combinedMinX) + 8)),\n    Math.max(8, Math.ceil((combinedMaxY - combinedMinY) + 4))\n  );\n  labelContainer.position.set(Math.round(tokenObject.w / 2), 0);\n  labelContainer.visible = tokenObject.visible;\n}\n\nfunction updateResilienceLabel(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n\n  const resilience = getResilienceValue(tokenObject.document);\n  if (resilience === null || resilience === undefined) {\n    const label = tokenObject[KEYS.resilienceLabel];\n    if (!label) return;\n    label.parent?.removeChild(label);\n    label.destroy();\n    delete tokenObject[KEYS.resilienceLabel];\n    return;\n  }\n\n  let label = tokenObject[KEYS.resilienceLabel];\n  const staleLabel = !!label && (\n    label.destroyed ||\n    label.parent == null ||\n    label.parent !== tokenObject\n  );\n  if (staleLabel) {\n    clearDisplayObject(label);\n    delete tokenObject[KEYS.resilienceLabel];\n    label = null;\n  }\n\n  if (!label) {\n    label = new PIXI.Container();\n    label.eventMode = \"passive\";\n    label.interactiveChildren = true;\n\n    const hitBox = new PIXI.Graphics();\n    hitBox.eventMode = \"static\";\n    hitBox.interactive = true;\n    hitBox.buttonMode = true;\n    hitBox.cursor = \"help\";\n\n    const icon = createOverlayIconSprite(ICON_SRC_RES, OVERLAY_FONT_SIZE + 1);\n    const valueText = new PreciseTextClass(\"\", getIconValueStyle());\n    tuneOverlayText(valueText);\n    valueText.anchor.set(0, 0.5);\n    valueText.eventMode = \"none\";\n\n    label.addChild(hitBox);\n    label.addChild(icon);\n    label.addChild(valueText);\n    label._hitBox = hitBox;\n    label._icon = icon;\n    label._valueText = valueText;\n    tokenObject.addChild(label);\n    tokenObject[KEYS.resilienceLabel] = label;\n\n    bindTooltipHandlers(hitBox, () => ({\n      title: \"Resilience\",\n      description: \"Resilience value used for durability and damage resolution thresholds.\"\n    }));\n  }\n\n  const hitBox = label._hitBox;\n  const icon = label._icon;\n  const valueText = label._valueText;\n  if (!hitBox || !icon || !valueText) {\n    clearDisplayObject(label);\n    delete tokenObject[KEYS.resilienceLabel];\n    return updateResilienceLabel(tokenObject);\n  }\n\n  valueText.text = `${resilience}`;\n  tuneOverlayText(valueText);\n  const gap = 4;\n  const padX = 3;\n  const padY = 2;\n  icon.position.set(0, Math.round(-icon.height / 2));\n  valueText.position.set(Math.round(icon.width + gap), 0);\n  const blockWidth = icon.width + gap + valueText.width;\n  const blockHeight = Math.max(icon.height, valueText.height);\n  drawHitBoxRect(\n    hitBox,\n    -padX,\n    Math.round(-(blockHeight / 2) - padY),\n    Math.round(blockWidth + (padX * 2)),\n    Math.round(blockHeight + (padY * 2))\n  );\n\n  const rowGap = Math.max(18, Math.max(icon.height, valueText.height) + 4);\n  const rightTopY = (tokenObject.h / 2) - (rowGap / 2);\n  label.position.set(Math.round(tokenObject.w + TOKEN_CONTROL_PAD), Math.round(rightTopY));\n  label.visible = tokenObject.visible;\n}\n\nfunction clearAllResilienceLabels() {\n  forEachSceneToken((token) => {\n    const label = token[KEYS.resilienceLabel];\n    if (!label) return;\n    label.parent?.removeChild(label);\n    label.destroy();\n    delete token[KEYS.resilienceLabel];\n  });\n}\n\nfunction clearAllNameLabels() {\n  forEachSceneToken((token) => {\n    const labelContainer = token[KEYS.nameLabel];\n    if (!labelContainer) return;\n    labelContainer.parent?.removeChild(labelContainer);\n    labelContainer.destroy({ children: true });\n    delete token[KEYS.nameLabel];\n  });\n\n  const orphaned = [];\n  for (const child of canvas.tokens.children ?? []) {\n    if (child?.[KEYS.nameLabelMarker] === true) orphaned.push(child);\n  }\n  for (const labelContainer of orphaned) clearDisplayObject(labelContainer);\n}\n");
})();
