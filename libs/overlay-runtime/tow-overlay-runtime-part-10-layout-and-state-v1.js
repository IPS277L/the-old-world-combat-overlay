// Auto-generated by macros/tools/build-overlay-runtime-libs.mjs
// Registers overlay runtime source part: 10-layout-and-state
(() => {
  const bundle = game["towOverlayRuntimeBundleV1"] ?? (game["towOverlayRuntimeBundleV1"] = {
    version: "1.0.0",
    parts: new Map(),
    order: ["00-header-and-combat","10-layout-and-state","20-controls","30-status-and-api"]
  });
  bundle.version = "1.0.0";
  if (!(bundle.parts instanceof Map)) bundle.parts = new Map();
  bundle.parts.set("10-layout-and-state", "function clearDisplayObject(displayObject) {\n  if (!displayObject) return;\n  displayObject.parent?.removeChild(displayObject);\n  displayObject.destroy({ children: true });\n}\n\nfunction ensureTokenOverlayInteractivity(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  if (typeof tokenObject[KEYS.tokenInteractiveChildrenOriginal] === \"undefined\") {\n    tokenObject[KEYS.tokenInteractiveChildrenOriginal] = tokenObject.interactiveChildren === true;\n  }\n  if (typeof tokenObject[KEYS.tokenHitAreaOriginal] === \"undefined\") {\n    tokenObject[KEYS.tokenHitAreaOriginal] = tokenObject.hitArea ?? null;\n  }\n  tokenObject.interactiveChildren = true;\n}\n\nfunction updateTokenOverlayHitArea(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const points = [\n    { x: 0, y: 0 },\n    { x: tokenObject.w, y: 0 },\n    { x: 0, y: tokenObject.h },\n    { x: tokenObject.w, y: tokenObject.h }\n  ];\n  const overlayChildren = [\n    tokenObject[KEYS.woundUI],\n    tokenObject[KEYS.nameLabel],\n    tokenObject[KEYS.resilienceLabel],\n    tokenObject[KEYS.statusPaletteLayer]\n  ].filter((child) => child && !child.destroyed);\n\n  for (const child of overlayChildren) {\n    const bounds = child.getBounds?.();\n    if (!bounds) continue;\n    const corners = [\n      { x: bounds.x, y: bounds.y },\n      { x: bounds.x + bounds.width, y: bounds.y },\n      { x: bounds.x, y: bounds.y + bounds.height },\n      { x: bounds.x + bounds.width, y: bounds.y + bounds.height }\n    ];\n    for (const corner of corners) {\n      const local = tokenObject.toLocal(corner);\n      points.push({ x: local.x, y: local.y });\n    }\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  for (const p of points) {\n    minX = Math.min(minX, p.x);\n    minY = Math.min(minY, p.y);\n    maxX = Math.max(maxX, p.x);\n    maxY = Math.max(maxY, p.y);\n  }\n  if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return;\n  const pad = 3;\n  const hitBounds = {\n    x: minX - pad,\n    y: minY - pad,\n    width: Math.max(1, (maxX - minX) + (pad * 2)),\n    height: Math.max(1, (maxY - minY) + (pad * 2))\n  };\n  tokenObject.hitArea = new PIXI.Rectangle(\n    hitBounds.x,\n    hitBounds.y,\n    hitBounds.width,\n    hitBounds.height\n  );\n  tokenObject[KEYS.layoutBounds] = { ...hitBounds };\n  drawCustomLayoutBorder(tokenObject);\n}\n\nfunction restoreTokenOverlayInteractivity(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const prior = tokenObject[KEYS.tokenInteractiveChildrenOriginal];\n  if (typeof prior !== \"boolean\") return;\n  tokenObject.interactiveChildren = prior;\n  delete tokenObject[KEYS.tokenInteractiveChildrenOriginal];\n  if (KEYS.tokenHitAreaOriginal in tokenObject) {\n    tokenObject.hitArea = tokenObject[KEYS.tokenHitAreaOriginal];\n    delete tokenObject[KEYS.tokenHitAreaOriginal];\n  }\n}\n\nfunction ensureCustomLayoutBorder(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return null;\n  let border = tokenObject[KEYS.layoutBorder];\n  if (!border || border.destroyed || border.parent !== tokenObject) {\n    if (border && !border.destroyed) clearDisplayObject(border);\n    border = new PIXI.Graphics();\n    border.eventMode = \"none\";\n    tokenObject.addChild(border);\n    tokenObject[KEYS.layoutBorder] = border;\n  }\n  return border;\n}\n\nfunction drawCustomLayoutBorder(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const border = ensureCustomLayoutBorder(tokenObject);\n  if (!border) return;\n  const bounds = tokenObject[KEYS.layoutBounds];\n  border.clear();\n  if (!bounds) return;\n  const borderStyle = getLayoutBorderStyle(tokenObject);\n  border.lineStyle({\n    width: borderStyle.width,\n    color: LAYOUT_BORDER_COLOR,\n    alpha: borderStyle.alpha,\n    alignment: 0.5,\n    cap: \"round\",\n    join: \"round\"\n  });\n  border.drawRoundedRect(\n    bounds.x,\n    bounds.y,\n    bounds.width,\n    bounds.height,\n    borderStyle.radius\n  );\n}\n\nfunction updateCustomLayoutBorderVisibility(tokenObject, { hovered = null, controlled = null } = {}) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const border = ensureCustomLayoutBorder(tokenObject);\n  if (!border) return;\n  const isHovered = (typeof hovered === \"boolean\")\n    ? hovered\n    : (tokenObject.hover === true || tokenObject._hover === true);\n  const isControlled = (typeof controlled === \"boolean\")\n    ? controlled\n    : (tokenObject.controlled === true || tokenObject._controlled === true);\n  border.visible = tokenObject.visible && (isHovered || isControlled);\n}\n\nfunction clearCustomLayoutBorder(tokenObject) {\n  const border = tokenObject?.[KEYS.layoutBorder];\n  if (border) clearDisplayObject(border);\n  delete tokenObject?.[KEYS.layoutBorder];\n  delete tokenObject?.[KEYS.layoutBounds];\n}\n\nasync function bringTokenToFront(tokenObject) {\n  if (!tokenObject || tokenObject.destroyed) return;\n  const tokenDocument = tokenObject.document ?? null;\n  if (tokenDocument?.isOwner && typeof tokenDocument.update === \"function\") {\n    const sorts = (canvas?.tokens?.placeables ?? [])\n      .map((token) => Number(token?.document?.sort ?? NaN))\n      .filter((value) => Number.isFinite(value));\n    const highestSort = sorts.length ? Math.max(...sorts) : Number(tokenDocument.sort ?? 0);\n    const currentSort = Number(tokenDocument.sort ?? 0);\n    if (Number.isFinite(highestSort) && currentSort <= highestSort) {\n      if (currentSort < highestSort) {\n        await tokenDocument.update({ sort: highestSort + 1 });\n      }\n      return;\n    }\n  }\n\n  const layer = tokenObject.layer ?? canvas?.tokens;\n\n  if (typeof layer?.bringToFront === \"function\") {\n    layer.bringToFront(tokenObject);\n    return;\n  }\n\n  if (typeof tokenObject.bringToFront === \"function\") {\n    tokenObject.bringToFront();\n    return;\n  }\n\n  const parent = tokenObject.parent;\n  if (!parent || typeof parent.setChildIndex !== \"function\" || !Array.isArray(parent.children)) return;\n  const topIndex = Math.max(0, parent.children.length - 1);\n  const currentIndex = typeof parent.getChildIndex === \"function\"\n    ? parent.getChildIndex(tokenObject)\n    : -1;\n  if (currentIndex === topIndex) return;\n  parent.setChildIndex(tokenObject, topIndex);\n}\n\nfunction getDeadFilterTargets(tokenObject) {\n  return [tokenObject?.mesh, tokenObject?.icon].filter(Boolean);\n}\n\nfunction ensureDeadVisual(tokenObject) {\n  if (!tokenObject) return;\n  const hasDead = !!tokenObject.document?.actor?.hasCondition?.(\"dead\");\n  if (!hasDead) {\n    clearDeadVisual(tokenObject);\n    return;\n  }\n  // Rebuild each refresh so tweaks to filter settings apply immediately.\n  if (tokenObject[KEYS.deadVisualState]) clearDeadVisual(tokenObject);\n\n  const targets = getDeadFilterTargets(tokenObject);\n  const entries = [];\n\n  for (const displayObject of targets) {\n    const originalFilters = Array.isArray(displayObject.filters) ? [...displayObject.filters] : [];\n    const originalAlpha = Number(displayObject.alpha ?? 1);\n    const originalTint = Number(displayObject.tint ?? 0xFFFFFF);\n    const deadFilter = new PIXI.ColorMatrixFilter();\n    deadFilter.brightness(0.70, false);\n    displayObject.alpha = Math.max(0.92, originalAlpha);\n    if (\"tint\" in displayObject) displayObject.tint = 0x5A5A5A;\n    displayObject.filters = [...originalFilters, deadFilter];\n    entries.push({ displayObject, originalFilters, deadFilter, originalAlpha, originalTint });\n  }\n\n  tokenObject[KEYS.deadVisualState] = { entries };\n}\n\nfunction clearDeadVisual(tokenObject) {\n  const state = tokenObject?.[KEYS.deadVisualState];\n  if (!state) return;\n\n  for (const entry of state.entries ?? []) {\n    const displayObject = entry?.displayObject;\n    if (!displayObject || displayObject.destroyed) continue;\n    displayObject.filters = Array.isArray(entry.originalFilters) ? entry.originalFilters : null;\n    if (typeof entry.originalAlpha === \"number\") displayObject.alpha = entry.originalAlpha;\n    if (typeof entry.originalTint === \"number\" && \"tint\" in displayObject) displayObject.tint = entry.originalTint;\n  }\n\n  delete tokenObject[KEYS.deadVisualState];\n}\n\nfunction getWoundCount(tokenDocument) {\n  const actor = tokenDocument?.actor;\n  if (!actor) return null;\n  const liveItems = actor.items?.contents ?? [];\n  const itemWounds = Array.isArray(liveItems)\n    ? liveItems.filter((item) => item.type === WOUND_ITEM_TYPE).length\n    : (Array.isArray(actor.itemTypes?.wound) ? actor.itemTypes.wound.length : 0);\n\n  // Minions can become dead via system addWound without creating wound items.\n  const isMinion = actor.type === \"npc\" && actor.system?.type === \"minion\";\n  if (isMinion && actor.hasCondition?.(\"dead\")) return Math.max(1, itemWounds);\n  return itemWounds;\n}\n\nfunction getActorWoundItemCount(actor) {\n  if (!actor) return 0;\n  const items = actor.items?.contents ?? [];\n  if (Array.isArray(items)) return items.filter((item) => item.type === WOUND_ITEM_TYPE).length;\n  if (Array.isArray(actor.itemTypes?.wound)) return actor.itemTypes.wound.length;\n  return 0;\n}\n\nfunction getMaxWoundLimit(actor) {\n  if (!actor || actor.type !== \"npc\") return null;\n  if (actor.system?.type === \"minion\") return 1;\n  if (!actor.system?.hasThresholds) return null;\n\n  const defeatedThreshold = Number(actor.system?.wounds?.defeated?.threshold ?? NaN);\n  if (!Number.isFinite(defeatedThreshold) || defeatedThreshold <= 0) return null;\n  return defeatedThreshold;\n}\n\nfunction isAtWoundCap(actor) {\n  const cap = getMaxWoundLimit(actor);\n  if (!Number.isFinite(cap)) return false;\n\n  if (actor.system?.type === \"minion\") {\n    if (actor.hasCondition?.(\"dead\")) return true;\n  }\n  return getActorWoundItemCount(actor) >= cap;\n}\n\nasync function syncNpcDeadFromWounds(actor) {\n  if (!actor || actor.type !== \"npc\" || !canEditActor(actor)) return;\n  if (actor.system?.type === \"minion\") return;\n  if (!actor.system?.hasThresholds || typeof actor.system?.thresholdAtWounds !== \"function\") return;\n  const state = game[MODULE_KEY];\n  if (!state) return;\n  if (!state.deadSyncInFlight) state.deadSyncInFlight = new Set();\n\n  const actorKey = actor.uuid ?? actor.id;\n  if (!actorKey || state.deadSyncInFlight.has(actorKey)) return;\n  state.deadSyncInFlight.add(actorKey);\n\n  try {\n    const woundCount = getActorWoundItemCount(actor);\n    const threshold = actor.system.thresholdAtWounds(woundCount);\n    const shouldBeDead = threshold === \"defeated\";\n    const hasDead = !!actor.hasCondition?.(\"dead\");\n    if (shouldBeDead === hasDead) return;\n\n    if (shouldBeDead) {\n      await runActorOpLock(actor, \"condition:dead\", async () => {\n        if (actor.hasCondition?.(\"dead\")) return;\n        await actor.addCondition(\"dead\");\n      });\n    } else {\n      await runActorOpLock(actor, \"condition:dead\", async () => {\n        if (!actor.hasCondition?.(\"dead\")) return;\n        await actor.removeCondition(\"dead\");\n      });\n    }\n  } finally {\n    state.deadSyncInFlight.delete(actorKey);\n  }\n}\n\nfunction queueDeadSyncFromWounds(actor) {\n  if (!actor) return;\n  const state = game[MODULE_KEY];\n  if (!state) return;\n  if (!state.deadSyncTimers) state.deadSyncTimers = new Map();\n\n  const actorKey = actor.uuid ?? actor.id;\n  if (!actorKey) return;\n\n  let debounced = state.deadSyncTimers.get(actorKey);\n  if (typeof debounced !== \"function\") {\n    debounced = foundry.utils.debounce((latestActor) => {\n      void syncNpcDeadFromWounds(latestActor).catch((error) => {\n        console.error(\"[overlay-toggle] Failed to sync dead condition from wounds.\", error);\n      });\n    }, DEAD_SYNC_DEBOUNCE_MS);\n    state.deadSyncTimers.set(actorKey, debounced);\n  }\n  debounced(actor);\n}\n\nasync function syncWoundsFromDeadState(actor) {\n  if (!actor || !canEditActor(actor)) return;\n  const state = game[MODULE_KEY];\n  if (!state) return;\n  if (!state.deadPresenceByActor) state.deadPresenceByActor = new Map();\n\n  const actorKey = actor.uuid ?? actor.id;\n  if (!actorKey) return;\n\n  const hasDead = !!actor.hasCondition?.(\"dead\");\n  const wasDead = state.deadPresenceByActor.get(actorKey) === true;\n  state.deadPresenceByActor.set(actorKey, hasDead);\n\n  const cap = getMaxWoundLimit(actor);\n  if (!Number.isFinite(cap) || cap <= 0) return;\n\n  if (hasDead) {\n    await runActorOpLock(actor, \"dead-wound-sync\", async () => {\n      const current = getActorWoundItemCount(actor);\n      const missing = Math.max(0, cap - current);\n      if (missing <= 0) return;\n      // Create wounds one-by-one to avoid duplicate side-effects from batched creation.\n      for (let i = 0; i < missing; i++) {\n        await actor.createEmbeddedDocuments(\"Item\", [{ type: WOUND_ITEM_TYPE, name: \"Wound\" }]);\n      }\n    }).catch((error) => {\n      console.error(\"[overlay-toggle] Failed to sync wounds from dead condition.\", error);\n    });\n    return;\n  }\n\n  if (!wasDead) return;\n  // If dead was removed after a wound decrement, preserve current wound count.\n  // Only run the legacy \"clear all wounds\" behavior when still at full cap.\n  if (getActorWoundItemCount(actor) < cap) return;\n  await runActorOpLock(actor, \"dead-wound-sync\", async () => {\n    const maxPasses = Math.max(1, getActorWoundItemCount(actor) + 2);\n    for (let i = 0; i < maxPasses; i++) {\n      const wounds = (actor.items?.contents ?? []).filter((item) => item.type === WOUND_ITEM_TYPE);\n      if (!wounds.length) break;\n      const toDelete = wounds.find((wound) => wound.system?.treated !== true) ?? wounds[wounds.length - 1];\n      if (!toDelete?.id || !actor.items.get(toDelete.id)) break;\n      await actor.deleteEmbeddedDocuments(\"Item\", [toDelete.id]);\n    }\n  }).catch((error) => {\n    console.error(\"[overlay-toggle] Failed to clear wounds after removing dead condition.\", error);\n  });\n}\n\nfunction queueWoundSyncFromDeadState(actor) {\n  if (!actor) return;\n  const state = game[MODULE_KEY];\n  if (!state) return;\n  if (!state.deadToWoundSyncTimers) state.deadToWoundSyncTimers = new Map();\n\n  const actorKey = actor.uuid ?? actor.id;\n  if (!actorKey) return;\n\n  let debounced = state.deadToWoundSyncTimers.get(actorKey);\n  if (typeof debounced !== \"function\") {\n    debounced = foundry.utils.debounce((latestActor) => {\n      void syncWoundsFromDeadState(latestActor);\n    }, DEAD_TO_WOUND_SYNC_DEBOUNCE_MS);\n    state.deadToWoundSyncTimers.set(actorKey, debounced);\n  }\n  debounced(actor);\n}\n\nfunction primeDeadPresence(actor) {\n  if (!actor) return;\n  const state = game[MODULE_KEY];\n  if (!state) return;\n  if (!state.deadPresenceByActor) state.deadPresenceByActor = new Map();\n  const actorKey = actor.uuid ?? actor.id;\n  if (!actorKey || state.deadPresenceByActor.has(actorKey)) return;\n  state.deadPresenceByActor.set(actorKey, !!actor.hasCondition?.(\"dead\"));\n}\n\nfunction getResilienceValue(tokenDocument) {\n  return tokenDocument?.actor?.system?.resilience?.value ?? null;\n}\n\nasync function addWound(actor) {\n  if (!canEditActor(actor)) {\n    warnNoPermission(actor);\n    return;\n  }\n  if (isAtWoundCap(actor)) return;\n  if (typeof actor.system?.addWound === \"function\") {\n    await actor.system.addWound({ roll: false });\n  } else {\n    await actor.createEmbeddedDocuments(\"Item\", [{ type: WOUND_ITEM_TYPE, name: \"Wound\" }]);\n  }\n}\n\nasync function removeWound(actor) {\n  if (!canEditActor(actor)) {\n    warnNoPermission(actor);\n    return;\n  }\n\n  await runActorOpLock(actor, \"remove-wound\", async () => {\n    const wounds = (actor.items?.contents ?? []).filter((item) => item.type === WOUND_ITEM_TYPE);\n    const isMinion = actor.type === \"npc\" && actor.system?.type === \"minion\";\n    if (!wounds.length) {\n      if (isMinion && actor.hasCondition?.(\"dead\")) {\n        await actor.removeCondition(\"dead\");\n      }\n      return;\n    }\n\n    const toDelete = wounds.find((wound) => wound.system?.treated !== true) ?? wounds[wounds.length - 1];\n    if (!toDelete?.id) return;\n    if (!actor.items.get(toDelete.id)) return;\n    await actor.deleteEmbeddedDocuments(\"Item\", [toDelete.id]);\n\n    // Minions can stay flagged dead after last wound is removed; clear dead immediately.\n    if (isMinion && actor.hasCondition?.(\"dead\")) {\n      const remaining = getActorWoundItemCount(actor);\n      if (remaining <= 0) await actor.removeCondition(\"dead\");\n    }\n  });\n}\n");
})();
